\subsection{Language Overview}
The original intention for Erlang has made an impact on the language today \cite{RefWorks:76,RefWorks:77}. Erlang is a highly concurrent programming language and basically everything is a process. There is no shared memory between processes, and hence all communication is done by asynchronous message passing placing Erlang in the class of \emph{Message-oriented} languages. This eliminates many errors since a process can be implemented in isolation without sharing resources with other processes. In order to handle millions of processes they must be very lightweight, i.e., require little memory, have fast loading/destroying times and message passing must require little computational effort. Studies show \cite{RefWorks:74} that processes in Erlang are indeed lightweight, and that hundreds of thousands of processes can be handled without noticeably degrading the performance of the system. 

Because Erlang builds on the functional programming paradigm there is no mutable data. The absence of side-effects makes it easier to verify program correctness and also to parallelise the program. Some features from other functional programming languages are left out to keep the language simple and efficient. Currying is for instance not a feature in Erlang. 

Erlang is designed to run on reactive (non-stop) systems, e.g. an air traffic control system, and it is therefore possible to update Erlang software without shutting down the system. It is always possible to use the newest version of the software since a function call with a qualified name is dynamically linked in the run-time code. Changing the version of modules can be done by parsing a message to the process.

Compared to Standard ML, Erlang has a more dynamic type system. This means that some errors are only caught on runtime, e.g. a match operation may fail or a BIF (Build-In Function) may be evaluated with an illegal argument. It is possible though to create fault-tolerant programs by using mechanisms provided by Erlang to detect and handle such errors. Catch and throw constructs provide a mechanism for monitoring the evaluation of an expression. Another mechanism called \emph{linked processes} can be used to have a process monitor the behaviour of another process. If a process terminates (normally or abnormally) a signal is sent to all the linked processes together with a reason for the exit. The linked process can then act on this, e.g., try to recover from the error or terminate.