\subsection{The Producer-Consumer System in Erlang}
\label{sec:producerconsumererlang}

In this section we explain the basics of Erlang through the simple
producer-consumer system explained in section \ref{sec:cpn}. The setup
is two producer processes sending messages to two consumer
processes. The producers are informed which consumer to send data to
by reading the value of a shared store called "next\_consumer". A
shared store can only be accessed by one process at a time, i.e., the
store becomes locked when is it read and unlocked when it is written
to. Because of this interaction pattern it is important that when a
process access the store it always first reads the value and then
writes a (possibly the same) value back to the variable. This locking
mechanism is introduced to make it possible to, e.g., add one the
current value of the store.

In order to interact with such a shared process we have made a small
and very simple protocol. A process wanting to read the value of the
store sends the pair \code{\{get, Id\}}, where \code{get} is the atom
we have chosen for the read command and \code{Id} is the process
identifier of the sending process. The shared store will then become
locked and sends the value it contains back to the process. A process
writes a value to the store by sending the pair \code{\{set, Exp\}},
where \code{set} is the atom we have chosen for the write command and
\code{Exp} is some expression. The shared store will then become
unlocked and contain the value that \code{Exp} evaluates to.

\subsubsection{The Producer}

The basic unit of Erlang code is \emph{modules} containing attributes
and function declarations. A module must be stored in a \code{.erl}
file which can be compiled into a binary \code{.beam} file and
executed on the virtual machine. The module that contains the code for
the producer part of the producer-consumer system can be seen in
Listing~\ref{fig:erlangproducer}.


\begin{figure}
\label{fig:erlangproducer}
\begin{verbatim}
-module(producer).
-export([produce/1]).

produce(Data) ->
  Produced_data = Data + 2,
  io:format("Producing data ~w.~n", [Produced_data]),
  next_consumer ! {get, self()},
  receive 
    Nextcons -> 
      Consumer_ID = list_to_atom("consumer_ID" ++
      integer_to_list(Nextcons)),
      Consumer_ID ! Produced_data,
      next_consumer ! {set, Nextcons}
  end,
  timer:sleep(2000),
  produce(Produced_data).
}
\end{verbatim}
\end{figure}


The \emph{module declaration} is the only mandatory attribute declaration and in line 1 we see the declaration. A period (.) is used after each attribute and function declaration to separate them from one another. In line 2 we find the \emph{export declaration} that can be used to make functions visible to other modules. The functions are specified in a list on the form \emph{function\_name} / \emph{number\_of\_arguments}. These function can then be accessed by using the syntax \emph{module\_name}:\emph{function\_name} from outside the module. In this case the \code{produce} function taking one argument is the only function exported.

The module defines the function \code{produce}. A function is a sequence of clauses separated by semicolons (;) and terminated by a period (.). The function \code{produce} is defined in line 4 through 16 and has only a single clause. As we can see Erlang do not use any keyword for defining functions. To define a function, the name of the function is stated followed by the arguments in parenthesis. In this case the function \code{produce} takes one argument \code{Data}. The name of the function together with the arguments is called the clause head. It is followed by the symbol "\code{->}" and then the clause body where the expressions of the clause are defined (separated by comma (,)).

In Erlang \emph{atoms} are used to represent non-numerical constant values and are very similar to enumerated types in for instance C or Java. An atom either begins with a lowercase letter or is put into single quotation marks ('). The name of a function must be an atom, e.g., the function name \code{start} is an atom. We can also notice that the arguments begin with an uppercase letter. The arguments are essentially variables and in Erlang all variables must begin with an uppercase letter.

In line 4 we see the atom \code{produce} and the \emph{clause head} \code{producer (Data)} followed by the symbol \code{->} which indicates that the \emph{clause body} is about to start. In line 5 we find the first expression on the right hand side of the "=" operator, namely \code{Data + 2}. On the left hand side we find the new variable \code{Produced\_data}. Notice that "=" is not an assignment operator in Erlang but a \emph{pattern matching} operator. Thus in line 5 the value of the expression on the right hand side is matched to the expression on the left hand side, i.e., a single variable. This results in the value of the right hand side being assigned to the variable \code{Produced\_data}. In Erlang a variable can either be \emph{bound} or \emph{unbound}. A bound variable cannot get a new value assigned to it which is known as \emph{single assignment variables}.

In line 6 we encounter the first use of a \emph{built-in function} (BIF). The function \code{format} in the \code{io} module can be used to print text to the screen. \code{format} takes as arguments the string to be printed and a list of \emph{terms}. In Erlang terms is a piece of data of any type. The \verb|~w| in the string is substituted by the terms in the list in turn and the string is ended by the new line character \verb|~n|.

In line 7 the producer sends the pair \code{\{get, self()\}} to the shared store process registered under the name \code{next\_consumer}, using message passing. In Erlang tuples are a compound data type with a fixed number of elements. It is defined using curly brackets "\{" and "\}" as in line 7. The send operator, which is an exclamation mark (!), is used to send the messages to the shared store. The left hand side of the operator specifies the process that should receive the message, and on the right hand side the message to be sent. As we can see in line 7 the \code{producer} process is sending the tuple to a process called \code{next\_consumer}.

The atom \code{get} in the messages tells the shared store that the process wants to receive the data the shared store contains. The BIF function \code{self()} returns the process identifier of the currents process. Sending the process identifier enables the shared store to send the value back to the messages that requested it. The atom \code{get} also locks the shared store such that other processes cannot changes the value before this process sends a \code{set} message back.

Line 8 contains the Erlang keyword \emph{receive} that starts a \emph{receive expression}. Making a receive expression allows a process to receive the messages which have been sent by other processes to this process. A receive expression has a number of patterns which is matched against the incoming message and the body of the first pattern that matches is evaluated. The current process is blocked until a message that matches one of the patterns has been received. The receive expression in the \code{produce} function only has a single pattern. This pattern consists of the unbound variable \code{Nextcons} (seen in line 9) which becomes bound when the message is received. An unbound variable matches all expression which means that the producer process is ready to receive the data sent from the shared store.

In line 10 and 11 the identifier of the consumer process is constructed. These two lines construct an atom containing first \code{consumer\_ID} followed by the identifier received from the shared store. The way this is done is by using the BIF \code{integer\_to\_list} to turn the received identifier into a list. In Erlang there are no strings which means that \code{"consumer\_ID"} is actually a list of integers. The two lists are concatenated using the list operator \code{++}. The resulting list is converted into an atom using the BIF \code{list\_to\_atom}.

In line 12 the produced data is sent to the consumer using the constructed identifier from line 10 and 11. In line 13 the pair \code{\{set, Nextcons\}} is sent to the shared store to unlock it, thus making the value available to other processes. The receive expression is ended in line 14 by the keyword \code{end}.

The process is put to sleep for 2000 milliseconds in line 15. This is done by using the BIF \code{sleep} in the module \code{timer}. Finally in, line 16 the \code{producer} function makes a recursive call to itself with the argument \code{Produced\_data}, i.e., the value of \code{Data} increased by two. It is important to notice that the last function call in the sequence of expressions in the clause body is the recursive call. This is known as \emph{tail-recursion}. Using tail-recursion allows the compiler to replace the function call with a jump to the start of the function, and hence the execution stack will not be filled with return addresses. So the result is a function that will loop forever.

\subsubsection{The Consumer}
The module that holds the code for the consumer part of the producer-consumer system can be seen in Listing~\ref{fig:erlangconsumer}. The first two lines are very similar to those of Listings~\ref{fig:erlangproducer}. First, we see the module declaration that declares the name of the module followed be the export declaration which states that the function \code{consume} with no arguments should be visible from outside the module.

\begin{figure}[h!]
\begin{verbatim}
-module(consumer).
-export([consume/0]).

consume() ->
  receive
    Data ->
      io:format("Consuming data ~w.~n", [Data]),
      consume()
  end.
\end{verbatim}
\end{figure}

Line 4 through 9 defines the \code{consume} function. First, we see the clause head consisting of the atom \code{consume} and an empty list of arguments. Following the symbol "\code{->}" we see the clause body which begins (in line 5) with a receive expression. This receive expression has a single pattern which consists of an unbound variable \code{Data} that becomes bound when the message is received. This means that the consumer process is ready to receive any kind of data that must be sent to it.

In line 7, the BIF \code{format} is used to print the received data to the screen. In line 8, the function makes a recursive call to put the process in a state ready to receive a new message. Again, the last function call in the sequence of expressions is the recursive call which means that this function also uses tail-recursion. Finally, in line 9 the receive expression is ended with the keyword \emph{end}. 

\subsubsection{The Shared Store}
\label{subsec:thesharedstore}
The shared store can be viewed as a global variable which can be accessed by any running Erlang process. In Listing~\ref{fig:erlangshared} is shown the implementation of the module \code{shared} which has the behaviour of a shared store. At the top of the module we find the module declaration and the export declaration that exports the \code{start} function. The \code{start} function takes one argument, namely the initial value of the store. The \code{handle\_request} function takes one argument which is the current value of the shared store.

\begin{figure}[h!]
\begin{verbatim}
- module(shared).
- export([start/1]).

start(Init_value) -> 
  handle_request(Init_value).

handle_request(Value) -> 
  receive 
    {get, Id} -> 
	  Id ! Value
  end,
  receive 
    {set, New_value} -> 
	  handle_request(New_value)
  end.
\end{verbatim}
\end{figure}

The function \code{handle\_request} contains two receive expressions. The first blocks the process until it receives a pair containing the atom \code{get} and a process identifier. It then sends \code{Value} back to the requesting process. The process then moves on to the next receive expression where it is blocked (locked) until it receives a pair containing the atom \code{set} and a value \code{New\_value}. A recursive call is then made with \code{New\_value} as argument, which then becomes the new value of the shared store. The recursive call also unlocks the store and it is ready to receive a new \code{get} request.

\subsubsection{Register and Spawn Processes}

We need a process that starts the \code{producer}, the \code{consumer}, and the \code{shared} processes, in order to get the producer-consumer system running. In Listing~\ref{fig:erlangsystem} we find the \code{system} module doing exactly this. The \code{start} function is defined in line 4 through 9. The BIF function \code{spawn} creates a new process and returns the process identifier (pid) that has been assigned to that process. \code{spawn} takes as arguments the module name, the name of the function that starts the process, and a list of arguments to that function. In line 5 \code{spawn} is called with the module \code{shared}, the function \code{start} and an empty list because the function \code{start} in the module \code{shared} takes on arguments.

\begin{figure}[h!]
\begin{verbatim}[style=erlangcode, caption=The module system.erl, label=fig:erlangsystem]
-module(system).
-export([start/0]).

start() ->
  register(next_consumer, spawn(shared, start, [1])),
  register(consumer_ID1, spawn(consumer, consume, [])),
  register(consumer_ID2, spawn(consumer, consume, [])),
  spawn(producer, produce, [1]),
  spawn(producer, produce, [2]).
\end{verbatim}
\end{figure}

In line 5 we also see the use of the BIF \code{register}. This function is used to register processes under symbolic names. The function takes as argument an atom which is the symbolic name of the process and the pid of the process. In our case we register the newly spawned \code{shared} process under the symbolic name "next\_consumer". This enables the \code{producer} processes to send messages to the \code{next\_consumer} process without knowing the pid of the shared store.

In line 6 through 9 two \code{producer} processes and two \code{consumer} processes are spawned using the \code{spawn} function. The \code{consumer} processes are started by calling the function \code{consume} with no arguments. The \code{producer} processes are started by calling the function \code{produce} given the arguments 1 and 2 respectively.

\subsubsection{The Record Data Structure}
The data structure \emph{record} could be used in the producer-consumer system to represent a message. A record definition consists of an atom which is the name of the record. This is followed by a tuple of atoms which defines the field names of the record. The definition of a \code{message} record can be seen in Listings~\ref{fig:erlangmessage}.

\begin{figure}[h!]
\begin{verbatim}
-record (message, {
	id,
	data
	}).
...

Msg = #message{id = self(), data = 1}
\end{verbatim}
\end{figure}


In lines 1-4, the \code{message} record with two field are defined, namely \code{id} and \code{data}. In line 7 of the pattern matching operator is used with a new variable \code{Msg} on the left hand side. On the right hand side we see the notation for creating a new record. The first field named \code{id} is assigned the pid of the current process and the second field named \code{data} is assigned the value 1.
