\chapter{Conclusion and Future Work}
\label{chap:confutwo}

In this thesis we showed how to automatically generate code from a CPN model to a target programming language using a structural code generation approach. We described the translation from ProPCPN to the Erlang programming language, and as a proof of concept we implemented a tool that, given a ProPCPN model, generates Erlang code. The generated code from a simple producer-consumer ProPCPN model was validated, and we found that the behaviour of the executions were equivalent to the behaviour of the CPN model. We investigated the expressive power of the constructed net class by modelling the industrial-sized routing protocol DYMO in ProPCPN, and validations indicated that the generated code was correct. In the following we summaries and conclude on the presented topics in this thesis.

\section{Approaches to Code Generation}
%discussion
% summary
Research done in related work shows that the chosen approach to automatic code generation from Petri nets has a large impact on the properties of the final code. Based on related work, we categorised automatic code generation from Petri nets into the four categories: decentralised, state space-, simulation- and structural-based. The state space based approach only works on small models because of the state explosion problem, and the decentralised approach would result in an enormous number of process instances for large models. We therefore decided to focus on the simulation-based and structural-based approach.

% simulation-based pro-cons
The main idea behind the simulation-based approach is to have a scheduler which, on the basis of the state of the environment, determines the control flow of the program. The process of determining which state to proceed to corresponds to finding enabled transitions in the CPN model. This resemblance to a CPN simulator makes it easier to capture the behaviour of the model in the program. Another advantage is that this approach does not restrict the net class that can be generated code from. The disadvantage of this approach is that the generated code tends to be in an unnatural programming style. This makes the code hard to modify or extend which may be required to adopt it into the environment in which it will be embedded. This approach also has the disadvantage that it can lead to inefficient code because the scheduler is called in between each state change which is time-consuming, and consequently can put a lot of overhead on the system.

% structural-based pro-cons
The code generated in the structural-based approach contains no central scheduler to control the flow of the program. The main idea is to recognise structures and regular patterns in the model, and have the control flow distributed across the program as jumps. Because of this, the structural-based approach produces more readable code than the simulation-based approach, since it looks more like it was written by a human programmer. The generated code would also often be more efficient, because the control flow is not controlled by a central component. The disadvantage of this approach is the restriction on the class of nets that code can be generated from. This is because general Petri nets provide much more opportunities of constructing different control flow structures than common programming languages.

% conclusion
We found that the structural-based approach was the most advantageous based on the discussion of the simulation-based and structural-based approaches. Generating readable code is very important to minimise the risk of introducing errors while extending and modifying the code. Furthermore, the simulation-based approach would be very similar to a CPN simulator, and they already exist, e.g., the simulator found in CPN Tools.

\section{Defining the ProPCPN Class}
In order to generate code in a structural-based manner we made a formal definition of a subclass of CPNs called Process-Partitioned Coloured Petri Nets (ProPCPNs). A ProPCPN is restricted in such a way that it is possible to recognise structures that can be translated into common programming language constructs. The main property of the class is that the CPN model can be partitioned into separate processes which run independently of each other. The control flow of a process is made explicit through the use of process places in the model. The control of a process can either flow unconditionally to another point, or conditionally to many points. It is possible to store data locally within a process instance using local places, and globally between process instances using shared places. A process instance can also send data to another process instance using buffer places. ProPCPN allow general CPN ML expressions, thus the expressive power of arc expressions and guard expressions are as strong as in CPN. 
   
\section{Generating Code from ProPCPN Models}
We created a technique for translating from ProPCPN models to a target language. The translation is divided into a number of phases, where the first three phases are independent of the target language. 

\subsection{Phase 1-3: Generating an AST}
The first phase is to decorate the ProPCPN model with process partitions, and assign types to places, transitions, and arcs. This is done in order to ease phase two, in which the decorated ProPCPN model is translated into a control flow graph (CFG). A CFG is constructed for each process partition of the ProPCPN model, and together they constitute the program. The translation in this phase consists of extracting the control flow from the model and making it explicit in the CFG, where it is represented as edges between blocks of statements. The phase also identifies program constructs, e.g., variables and synchronisation points, and translates them into statements. 

In phase three, the CFG is translated into an abstract syntax tree (AST) for a simple language that contains common program constructs. We have designed the language such that it can be translated into any common type of programming language. This phase translates the control flow given in the structure of the CFG into a tree consisting of nodes representing programming constructs. The statements in the blocks of the CFG are parsed and translated into subtrees in order to make the structure of statements explicit in the AST.

\subsection{Phase 3-5: Generating Erlang Source Code}
Until now, the phases of the translation have been independent of the target language. Phase four consists of translating the AST into a syntax tree for a specific programming language. We have chosen Erlang as the target programming language, thus we translate the AST into an Erlang program represented as an Erlang syntax tree (EST). The control flow, represented by goto statements in the AST, is translated into function calls, and the reading/writing of variables are translated into accessing/updating an environment record which is passed around with the function calls. Message passing between processes is native in Erlang which means that sending and receiving messages can be translated into native program constructs. 

The last phase prints the EST by traversing the tree and printing each node according the Erlang grammar. This produces the final Erlang source code which is the product of the translation. 

\section{Implementing the Translation}

% Technologies/TOOL: summary
As a proof of concept we have implemented the translation from ProPCPN models to Erlang code as an Eclipse plug-in for the ASAP tool. Through the use of wizards the user can import a CPN model into the workspace, and then generate Erlang code from that model. The user is also able to inspect the phases in the translation. Through the wizard the user can choose to have the CFG, AST, or EST written in files which can then be presented visually as tree structures. The implementation shows that the translation is indeed feasible in practise, and we found that extending the implementation with new features seemed fairly easy.  

% Evaluation: summary
To validate the generated Erlang code of the producer-consumer system, we compared it to manually translated code from the model. The generated code is very similar to code handwritten in the manually translated code. The code was also validated by executing it, and the behaviour of the program was documented in a message sequence chart. The results of the executions of the generated code showed that the messages being passed between the processes were as expected. The execution of the program was also compared with a simulation of the same scenario in the ProPCPN model, and we found the behaviour to be equivalent. This builds confidence in the behaviour of the ProPCPN model being preserved in the generated Erlang program.

\section{DYMO -- A Large ProPCPN Model}
%DYMO
% summary
To show the expressive power of the net class, and that the translation works for larger and more advanced models, we built a ProPCPN model of the DYMO routing protocol. The DYMO protocol is an advanced industrial-size communication protocol that allows multi-hop communication in MANETs. The DYMO model captures the behaviour of the route discovery part of the DYMO protocol. It consists of eight modules containing a total of 49 places and 18 transitions.

Erlang code was generated from the ProPCPN DYMO model and the Erlang functions and expressions where implemented which took approximately 12 person-hours of work. To validate the generated code we built a test environment in which the code could be executed. A network simulator made it possible to run the generated code for the protocol on a number of nodes. A scenario could then be executed and afterwards the state of the protocol could be inspected to verify that routes had been established as expected. The DYMO model showed that it is possible to construct a model of an advanced industrial-size communication protocol using the ProPCPN net class. It also showed that the translation is able to cope with more advanced control flow issues, e.g., control flow branches.

\section{Perspectives in Code Generation}
The work in this thesis shows that it is possible, in an automatic way, to generate program code from a ProPCPN model. The user can create a model, then verify importing properties of the model, and finally generate code with the same behaviour and properties as the model.

With the automatic code generation, the task of manually implementing the system is eliminated. This task is often error-prone and time-consuming, and therefore very costly. We created a net class and showed that the translation from this class is feasible. Finally, we showed that it is in fact possible to implement the translation technique, and that the generated code has the same properties and behaviour as the model. We believe that this is a great assistance in the development of programs without errors.

\section{Future Work}
\label{futurework}

Having more time to our disposal, there are a number of aspects about automatic code generation from CP-nets that would be interesting to investigate further.

\subsection{Extending the Class of ProPCP-nets}
The class of ProPCP-nets described has enough expressive power to model industrial-sized communication protocols, as we have shown with the DYMO ProPCPN model. However, we do have a restriction that tends to increase the size of the models. According to (7) in definition~\ref{def:propcpn} in section~\ref{sec:netclassformal}, it is not allowed to have variables in a transition guard that appear on an input arc from a buffer place or a shared place. Removing this restriction from the class of ProPCP-nets would reduce the size of the DYMO model. It would also complicate the translation from AST to EST though, because a guard in the current definition cannot change value once evaluated. Allowing, e.g., variables on input arcs from shared places in the guard expressions have the consequence that a guard can change value after being evaluated. This is because another process instance may change the value of the shared place after the guard has been evaluated. Therefore, a locking mechanism would have to be implemented in the generated code in order to ensure that the value of the corresponding global variable do not change before the jump has been made and the function has been executed. Without the locking mechanism, a conditional jump could be made based on one value and when the target function of the jump was evaluated the value had changed. This would mean that the generated program could have executions that were not possible in the CPN model it was generated from. 

\subsection{Formally Verifying the Translation}
In this thesis we have described and implemented a translation from ProPCPN models to Erlang code. We have validated the result of the translation by executing the generated code and monitoring the behaviour. The behaviour was compared to simulations in the CPN model. As a subject for future work it would be interesting to make a more formal verification of the steps in the translation. This should be done in order to have a proof that each step preserves the behaviour of the CPN model. A proof that the translation is correct does not necessarily mean that an implementation of the translation generates correct code since the implementation might be incorrect. Therefore, it would also be interesting to develop a method to more formally verify that the concrete generated code has the same behaviour as the CPN model it was generated from.

\subsection{Enhancing the Code Generation Tool}
In this thesis we have used the implemented tool as a proof of concept, but there is still some work to be done in order to enhance the usefulness of the tool. A hierarchical CPN model is often more readable than the equivalent flat model. Hierarchical models do not have more expressive power, since a hierarchical CPN model can always be flattened as mentioned in section \ref{sec:dymomodel}. Even though hierarchical models do not have more expressive power, it would be convenient if the tool supported hierarchical ProPCPN models, and automatically flattened them according to the steps in (p. 130, \cite{RefWorks:87}).

Expressions on arcs and in guards in a ProPCPN model are written in CPN ML. Our tool does not support automatic translation of these expressions, but having such an automatic translation would eliminate the need for manually modifying the generated code. It would also weed out some errors that might be introduced in the manual translation. Having the CPN ML and Erlang expressions in a parsed representation in the AST and EST would also allow for some optimisations. 

\subsection{Create a ProPCPN Editor Tool}
In this project we have used CPN Tools to create ProPCPN models. CPN Tools ensures that only valid CPN models can be created, e.g., that the initial marking of a place evaluates to a multi-set belonging to the colour set of that place. Having a ProPCPN editor has the following advantages: 

\begin{itemize}
\item The user is immediately prompted if trying to create something that is not allowed according to the ProPCPN definition, e.g., having an illegal colour set on a process place.
\item The ProPCPN models we have presented in this thesis are painted to better visually distinguish between the different place types. In a ProPCPN editor one could, e.g., have a toolbox containing the possibility of creating a local place which would automatically be painted green.  
\item The ProPCPN model created in the editor can then be given to the code generation tool. The tool does not need to check if the model is a ProPCPN model because the editor only outputs valid ProPCPN models
\item Most of the decoration in the first phase of the translation described in section \ref{sec:cpntodcpn} would be eliminated by having the user explicitly specifying the type of places.
\end{itemize}

The editor could be made, e.g., as an extension of CPN Tools, or using the Eclipse framework as we did with our implementation of the translation from ProPCPN to the Erlang programming language.
