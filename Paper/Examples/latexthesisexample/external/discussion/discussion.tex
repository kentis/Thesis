\chapter{Approach to Code~Generation}
\label{chap:codegeneration}
There are different approaches to automatically generate code from Petri nets, and the chosen strategy has a large impact on the properties of the final code. The approach should preserve the behaviour of the model, but the code generated in one approach might be very efficient, while the code in another approach may be very readable and extensible.

In this section the approaches on code generation from Petri nets are, based on the descriptions in \cite{RefWorks:4} and \cite{RefWorks:5}, divided into the four categories \emph{simulation-based}, \emph{structural-based}, \emph{state space-based} and \emph{decentralised approach}. In each approach we discuss related work, and for the \emph{structural based} and \emph{state space based} approaches we present Erlang code for the producer-consumer system as it would be generated in these approaches. These examples are used as a basis of the discussion of advantages and disadvantages, and to give a better understanding, of the two approaches. The generated code in both examples preserve the behaviour of the model, but are very different in programming style.

\section{Simulation-based Code Generation}
The basic idea in the simulation-based approach is to have a central component which controls the flow of the program on the basis of the state of the environment. This is done by a scheduler which given the current state of the system computes which state to proceed to. The process of determining which state to proceed to corresponds to finding an enabled transition in the CPN model.

The simulation-based approach is used by Philippi \cite{RefWorks:4} to generate Java code from a high-level Petri net. The idea is to make a class diagram which outlines the classes and method signatures of the program. From this diagram, classes with attribute definitions and methods with empty bodies are generated. The empty bodies are filled with the simulator code made from the formal model. After this, the structure of the Petri net is used to enhance the code to make it more efficient and more readable. The simulation-based approach is also used in the projects described in \cite{RefWorks:78} and \cite{RefWorks:2}. In the Course of Action Scheduling Tool (COAST) project \cite{RefWorks:2} the generated simulator code made from a CPN model (by CPN Tools) was used directly in the final implementation. The code was used for scheduling resources and planning of tasks. A similar approach was taken in the project \cite{RefWorks:78} which considered an access control system. This project made use of a simulation kernel generated by Design/CPN \cite{DESIGNCPN}, the predecessor of CPN Tools. The simulation kernel was generated on basis of a CPN model and after undergoing some automatic modifications, e.g., linking the code to external code libraries and changing the dialect of the language, the generated code was embedded into the final implementation of the control unit of the system.

\subsection{Simulation-based Producer-Consumer System}
In this section we describe how the producer-consumer model can be translated into the Erlang programming language using the simulation-based code generation approach. The producer and the consumer part of the model have been identified and leads to two different modules each of them containing a scheduler. The scheduler is an Erlang function that on the basis of a \emph{state id} (sid) decides which function is to be invoked next. This decision resembles computing enablings in a CPN model.

An Erlang module \code{system} (see Listing \ref{fig:simulationsystem}) is responsible for starting up \code{producer} and \code{consumer} processes, and a process to handle the shared store called \code{shared}. The \code{system} module has a single function called \code{start} which first spawns the shared store process \code{next\_consumer}. Next, two \code{consumer} processes are spawned and registered under the names "consumer\_ID1" and "consumer\_ID2" and analogously for two \code{producer} processes. This corresponds to the scenario from the CPN model described in section~\ref{sec:cpn}. All processes can now use this symbolic name to pass messages to other processes.

\input{discussion/code/prettySystemSim}

The module \code{shared} that implements a shared store is identical to the one presented in section~\ref{sec:erlang}. Processes can read the value of the store by sending a \code{get} messages along with a process identifier. Processes can also set the value of the shared store by sending a \code{set} message along with a value.

\paragraph{The producer part}
Listing~\ref{fig:simulationproducer} shows the manually translated Erlang code for the producer part of the producer-consumer CPN model. The Erlang module has a function named \code{start} that initialises the environment with the values given as arguments and calls the scheduler \code{producer\_scheduler} with the environment and the id of the initial state which is \code{producing}. The scheduler then chooses which function should be called given the state \code{Sid}.

\input{discussion/code/prettyProducerSim}

The producer can be in two states, namely \emph{producing} and \emph{sending} which is symbolised be the two atom by the same names. We can for instance see that the scheduler calls the function \code{produce\_data} when in the state \code{producing}. In this simple example the decision is easy since the producer process alternates between being producing and sending, but in the general case the scheduler might have to inspect the environment to determine which function is to be called next. The corresponds to the CPN simulator computing enabled transitions. 

The function \code{produce\_data} is a translation of the transition by the same name from the CPN model. This function first extract the necessary data from the environment by reading the value of the \code{data} field into a variable \code{Data}. In the CPN model this corresponds to getting input from the input arc from the place \code{Data}. Next, the function updates the environment by incrementing the \code{data} field by two and setting the \code{produced\_data} to the value of the input. Finally, the environment and the state identifier is returned. The returned state id reflects the state of the system after the environment has been updated.

At the bottom of Listing \ref{fig:simulationproducer} we find the function \code{send\_data} which is a translation of the transition \figitem{SendData} from the CPN model. This function follows the same steps as \code{produce\_data} by first reading \code{produced\_data} into a variable. In the CPN model the transition \figitem{SendData} gets the id of the consumer to send to from the shared place \figitem{NextConsumer}. In the code this corresponds to reading a value from \code{next\_consumer} which is done by sending a \code{get} messages and waiting to receive the value. When the value is received the identifier of the consumer is constructed and the variable \code{Data} is sent. Finally, \code{next\_consumer} is unlocked by sending a \code{set} message back and the environment is returned together with the state id.

\paragraph{The consumer part}

In Listing \ref{fig:simulationconsumer} we find the consumer module which also has a \code{start} function that sets up the environment and calls the scheduler \code{consumer\_scheduler}. The \code{consumer\_scheduler} has two states \emph{receiving} and \emph{consuming} similar to the producing and sending states of \code{producer\_scheduler}.

\input{discussion/code/prettyConsumerSim}

The function \code{receive\_data} is translated from the transition with the same name in the CPN model. This transition has an input arc from the place \figitem{Buffer} which in Erlang code corresponds to receiving a message from another process. This is done by means of a receive expression which waits for incoming messages and when a message is received the data is used to update the environment. Afterwards the updated environment along with the state identifier is returned.

When the consumer is in the consuming state the function \code{consume\_data} is called. This function starts out by extracting \code{received\_data} from the environment into the variable \code{Data}. In this case we do not do any manipulations on the received data and therefore \code{Data} is never read. Afterwards the environment along with the state identifier \code{receiving} is returned.

\subsection{Discussion of the Simulation-based Approach}
One of the advantages of the simulation-based approach is that it follows simulation of the model very closely. This way it is easier to establish that the behaviour of the generated code is the same as the behaviour of the model. Another advantages is that this approach do not put any restrictions on the class of nets it can generate code for as opposite to the structural approach.

Unfortunately, the simulation-based approach also has some disadvantages. As it can be seen from the example, the code is not very readable because it is not written in a natural programming style. It can therefore be very hard to make changes to the code or extend it. Modifying the code is often required in order to adopt it in the environment in which it will be embedded. This approach also has the disadvantage that it can lead to inefficient code. The reason for this is that the next state needs to be computed by the scheduler each time the state has changed. This means that in between each state change the scheduler is called which is time-consuming, and consequently can put a lot of overhead on the system.

\section{Structural-based Code Generation}
\label{sec:structuralcodegeneration}
The code generated in the structural-based approach contains no central component to control the flow of the program. Instead the control flow of the program is distributed across the program, e.g., to function calls in a functional programming language. The key idea of this approach is to recognise \emph{structures} (regular patterns) in the model. These structures are then mapped to well-known programming constructs like sequences, loops and case constructs. It is very hard (if not impossible) to identify such structures in Petri nets mainly because they provide much more opportunities of constructing different control flow structures than common programming languages \cite{RefWorks:4}. Because of this, it is necessary to restrict the class of nets in this approach. 

Philippi \cite{RefWorks:4} uses a structural-based approach to identify loops, \code{if} constructs and merge sequences of functions into one using the structure of the net. Another structural approach is found in \cite{RefWorks:5}. In this approach the focus is on identifying processes in a Petri net, i.e., parts of the net that works independent of one other or only have few synchronisation points. Afterwards local variables (i.e., information only used by one process) and communication channels are found. One of the conclusions in this work is that it is very hard to code generate for Petri nets in general because of the lack of programming structures in the net.

\subsection{Structural-based Producer-Consumer System}
The producer-consumer model presented in section \ref{sec:cpn} is in fact a member of a restricted subclass of CPNs. In chapter \ref{chap:netclass} we present the concrete subclass we have defined but for now it is enough to know that the model is a member of this subclass. In the following we show the manually translated Erlang code for the producer-consumer system using the structural approach. We leave out the \code{system} module because it is exactly the same as the system module in Listing \ref{fig:simulationsystem}. 

\paragraph{The producer part}
The Erlang code for the producer part of the producer-consumer system can be seen in Listing \ref{fig:structureproducer}. The first thing we notice is that the Erlang module has no scheduler function since the responsibility of choosing the next function to call is put into each function. Similar to the simulation-based approach, the \code{start} function sets up the environment and calls the first function to be invoked, namely \code{produce\_data}.

\input{discussion/code/prettyProducerStruct}

The first three lines of \code{produce\_data} are exactly the same as the \code{produce\_data} function in the simulation approach figure \ref{fig:simulationproducer}. The data is extracted from the environment and the environment is updated. But instead of returning the updated environment it is passed on as an argument to the \code{send\_data} function which is invoked next. The \code{send\_data} function is also very similar to that in the simulation-based approach. Again data is extracted and a request for the value of \code{next\_consumer} is sent. When the value is received the consumer ID is constructed and the data is sent to the consumer. Afterwards, \code{next\_consumer} is unlocked by sending a \code{set} message and in the end of the function \code{produce\_data} is called with the environment.

\paragraph{The consumer part}
In Listing~\ref{fig:structureconsumer} we see the Erlang code for the consumer. Again, there is no scheduler function instead the functions \code{receive\_data} and \code{consume\_data} call each other. In the \code{receive\_data} function, we recognise the same structure as in the simulation-based consumer. A receive expression is used to receive the messages sent by the producers. The received data is used to update the environment which is passed on to \code{consume\_data}. \code{consume\_data} simply reads the value of \code{received\_data} and calls \code{receive\_data} putting the consumer in a position ready to receive more data from the producer.

\input{discussion/code/prettyConsumerStruct}

\subsection{Discussion of the Structural-based Approach}
The advantage of using the structural-based approach is that more readable code is obtained than with the simulation-based approach. The coding style is more natural and looks more like it is written by a human programmer. The generated code would also often have a tendency to be more efficient because it does not have a central component which is called in between each state change. Also the code can take advantage of locality, i.e., the next state computation are done locally in each function and can there for utilise local properties.

The disadvantage of the structural approach is that there is a restriction on the class of nets that code can be generated from. This is because in order to generate code in a natural programming style identification of programming structures and control flow is needed. In a general Petri nets, this is not an easy task because they provide more general control flow structures than common programming languages. Because of this, it is necessary to restrict the class of nets in this approach. The control flow needs to be explicitly represented in the structure of the model. One of the topics of this thesis is to investigate how much the models needs to be restricted in order to be able to generate code for them.

\section{State Space based and Decentralised Approach}
The idea of the state space based approach is to use the state space of the model to compute the next state. In the state space we have all possible states and its successor states computed which alleviate the overhead of computing the successors each time. Since this method relies on the full state space to be generated it has a huge drawback because of the state space explosion problem. Because of this we do not find this method feasible and will not proceed in this direction.

The opposite of the centralised simulation-based approach is the decentralised approach. The idea is to implement each place and transition of the net as processes. Hence the program does not directly reflect the structure or state of the system. This approach has the advantage that the parallelism in the net is preserved but it also introduces a huge overhead because of the administration needed, e.g., for locks and messages passing.

\section{Summary of Approaches}
Above we have discussed four approaches to code generation. The simulation-based approach is able to generate code for the full class of models and we get code that closely follows the behaviour of the model. But the generated code is not written in a very natural way and it can become inefficient. On the other hand in the structural approach the generated code is more natural to a human programmer and it is therefore much easier to modify and extend the code.

For the rest of this thesis we focus on the structural-based approach. We define a subclass of CPNs and make a translation from this class into the Erlang programming language.
