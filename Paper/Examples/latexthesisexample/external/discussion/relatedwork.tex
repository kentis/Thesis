\section{Related work}
\label{sec:relatedwork}
In trying to establish the surroundings in which this thesis fits in we found it very helpful to categorise the related work. We have made four categories in which we will fit in both the related work as well as our own. The strategy used to generate code has a large impact on the properties of the outputted code. One strategy might produce very efficient code while another strategy's code might be very readable and extensible. We have divided approaches into the categories \emph{simulation based}, \emph{structural based}, \emph{state space based} and \emph{totally decentralised approach}. The categories are based on the descriptions made in \cite{RefWorks:4} and \cite{RefWorks:5}. In the following we look at each of these categories in turn and describe what classifies each category.

\subsection{Simulation based approach}
The idea in the simulation based approach is that a central component controls the flow of the program on the basis of the state of the environment. This central component could be viewed as a scheduler that, on the basis of the current state of the program, computes which state to proceed to next.

Philippi \cite{RefWorks:4} has a similar description of this approach and shows how to generate Java code from a high-level Petri net. His idea is to make a class diagram which outlines the classes and method signatures of the program. From this diagram, classes with attribute definitions and methods with empty bodies are generated. The empty bodies are filled with the simulator code made from the formal model. After this the structure of the Petri net is used to enhance the code to make it more efficient and more readable.

Other work to put into this category is the project described in \cite{RefWorks:78} and \cite{RefWorks:2}. In the Course of Action Scheduling Tool (COAST) project \cite{RefWorks:2} the generated simulator code from CPN Tools made from a CPN model was used directly in the final implementation. The code was put on a server and used for the scheduling resources and the planning of task. A similar approach was taken in the project \cite{RefWorks:78} which considered an access control system. Here the simulation kernel from Design/CPN \cite{RefWorks:3} made from a CPN model was used. After undergoing some automatic modifications, e.g. linking the code to external code libraries and changing the dialect of the language, the generated code was embedded into the final implementation of the control unit of the system.

\subsection{Structural based approach}
In the structured approach the code generator tries to recognise structures in the net. It searches for well-known programming constructs like sequences, loops and case constructs but the task is also to identify the control flow of the program. Because of this it is necessary to restrict the class of nets in this approach. It is very hard (if not impossible) to identify such constructs and control flow in general Petri nets.

As earlier mentioned Philippi uses a structural approach to enhance the code in \cite{RefWorks:4}. He tries to identify loops, if-constructs and merge sequences of functions into one using the structure of the net. Another structural approach is found in \cite{RefWorks:5}. In this approach the focus is on identifying processes in a Petri net i.e. parts of the net that works independent of one other or only have few synchronisation points. Afterwards local variables, i.e. information only used by one process, and communication channels are found. One of the conclusions in this work is that is very hard to code generate for Petri nets in general because of the lack of programming structures in the net.

\subsection{State space based and totally decentralised approach}
Instead of using the simulation based approach where computations of the next state is being done between each state change an idea is to use the state space of the model. In the state space we have all possible states and its successor states computed which alleviate the overhead of computing the successors each time\fxnote{Find an example of the state space approach e.g. Tau88}. Since this method relies on the full state space to be generated it has a huge drawback because of the state space explosion problem. Because of this we do not find this method feasible and will not proceed in this direction.

The opposite of the simulation based approach is the totally decentralised approach. In this approach the idea is to implement each place and transition of the net as a process. This way the program does not directly reflect the structure or state of the system\fxnote{Find an example of the totally decentralised approach}. This approach of course has the advantage that the parallelism in the net is preserved but it also introduces a huge overhead because of the administration needed e.g. for locks and messages parsing.