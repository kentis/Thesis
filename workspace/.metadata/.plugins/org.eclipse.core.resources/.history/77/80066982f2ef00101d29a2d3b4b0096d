\chapter{Background}
\label{chap:background}



\section{Coloured Petri Nets}
Common usage: Process and protocol modeling, concurrent programming. Operations:
Simulation, verification and analysis. More recently also software design.

Short intro to places, transitions and arcs?

\section{CPN Tools}

Graphical tool used to design CPN models. 

Reference, with url. Screenshot?

\subsection{CPN ML}
	
	CPN Tools uses the CPN ML language to specify declarations and net inscriptions.
	This language is an extension of the functional programming language Standard
	ML, developed at Edinburgh University.

\subsection{Declarations}
	
	

\subsection{Inscriptions}

\section{WebSocket}

The primary case study for this thesis is the WebSocket
protocol \cite{draft-ietf-hybi-thewebsocketprotocol}. In this section the model
that has been built will be described in full detail.

\subsection{Overview}

	\fig{Overview.eps}{Overview of CPN model of the WebSocket protocol}{overview}
	
	Shown in \figref{overview} is the top-level Overview of the WebSocket
	protocol as a CPN model.
	
	Resembles part of OSI model (ref), where top level is levels 6 and 7, middle
	level is level 5, and bottom level is levels 4 through 1. Two-way communication
	between levels.
	
	Circles represent places. They can contain tokens of a specified colour, and
	can have markings to define initial tokens.
	
	Double-bordered rectangles represent subpages. These are separate models that
	have input and output places that connect to the places on their parent page.
	This is done to keep the model structured and readable, and also allows reuse
	of pages in different parts of the model by instancing them, which will be
	described toward the end of the chapter. The details of each subpage will be
	examined in the following subsections.
	
	The places in the Overview have the following color sets:
	
	\begin{lstlisting}[label=lst:overview_colset,caption=Overview color sets]
	colset OPERATION = union
	CONNECT + TEXT + BINARY + 
	PING + PONG + CLOSE;
	
	colset MESSAGE = record
	Op: OPERATION *
	Message: STRING;
	
	colset MESSAGES = list MESSAGE;
	
	colset EVENT = union
	Msg:MESSAGE +
	ConnRequest +
	ConnResult:CONN_RESULT;
	
	colset EVENTS = list EVENT;
	
	colset CONN_REPLY = bool with
	(reject, accept);
	
	colset MSG_OR_CONN_REPLY = union
	Msg':MESSAGE +
	ConnReply:CONN_REPLY;
	
	colset MSGS_OR_CONN_REPLY 
	= list MSG_OR_CONN_REPLY;
	
	colset PACKET = union 
	HttpReq:HTTPREQ + 
	HttpRes:HTTPRES +
	WsFrame:WSFRAME;
	
	colset PACKETLIST = list PACKET;
	\end{lstlisting}
	
	A \lstinline:MESSAGE: consists of an \lstinline:OPERATION: and the
	\lstinline:STRING: message body. We can also have a list of
	\lstinline:MESSAGES: to keep them ordered. Lists will be explained in
	detail later.
	
	The client application sends \lstinline:MESSAGES: to the library and receives
	\lstinline:EVENTS: back, which can be either a \lstinline:MESSAGE: or a
	\lstinline:ConnReply:. The server application also receives \lstinline:EVENTS:,
	but can send either a \lstinline:MESSAGE: or a \lstinline:CONN_REPLY:, which is
	used for connection attempts. The \lstinline:CONN_REPLY: colorset is simply a
	boolean value with different names for true and false, for improving readability
	and semantics.
	
	Both libraries send and receive \lstinline:PACKET:s. These are abstract and not
	fully modeled or simulated actual network packets, as this is not relevant to
	how WebSocket works.

\subsection{Client Application}

	\fig{ClientApplication.eps}{The Client Application}{client_app}
	
	Laid out from top to bottom to loosely show sequence. 
	
	The places at the bottom represent the interface to the WebSocket library. To
	simplify the overview model and facilitate easier later modification
	and expansion, we have only two places that act as input and output. These are
	called Receive Client Events and Send Client Message, and are tagged In and
	Out respectively. These are connected to the respective places on the
	Overview, which are also connected to corresponding places in the WebSocket
	Library.
	
	
	\subsubsection{Variables}
	
		The arcs here have inscriptions on them containing variables. These are
		declared globally and can only be bound to colors of the colorset they are
		defined for. 
		
		When a transition fires, it will bind the tokens it is consuming to the
		variables of the inscriptions on the arcs from the respective places. These
		variables can then be used to produce new tokens, by direct manipulation
		and/or in conditional statemens. The expression that will produce the desired
		result is inscribed on the output arc. 
		
		A set of variables has been declared for the simple colorsets as follows:
		
		\begin{lstlisting}[label=lst:standard_vars,caption=Simple Colorset Variables]
		var u, u1, u2, u3: UNIT;
		var b, b1, b2, b3: BOOL;
		var i, j, k: INT;
		var s, s1, s2, s3: STRING;
		var ss, ss1, ss2: STRINGLIST;
		\end{lstlisting}
		
		Several variables for the same colorsets have been created for convenience in
		the cases where colors of the same type is consumed from different places. If the same variable was
		used on each arc from two different places, both places would need a token
		with the same value. 
		
		Variable declarations will be listed as they are encountered in the model.
		As a general guideline, most variables are named with the first letter of its
		colorset for non-lists, and the same letter plus the letter s for lists. On
		this subpage we have the following variables:
		
		\begin{lstlisting}[label=lst:client_app_vars,caption=Client Application
		Variables]
		var msg: MESSAGE;
		var msgs, msgs2: MESSAGES;
		var es: EVENTS;
		\end{lstlisting}
	
	\subsubsection{Queues}
	
		A lot of the places in this model rely on tokens being consumed in the same
		order they are produced, and to enforce this, queues are used, facilitated
		by lists. To describe a list in SML, we use \lstinline:[]: square brackets. By
		themselves they represent an empty list. To describe a populated list, we
		write each token inside the brackets separated by commas. An example of this
		is seen on the initial marking for the Messages to be sent place.
		
		To process such a list, we use the \lstinline-::- operator like this:
		\lstinline-head::tail-, where head is the first element in the list, and tail
		is all the following elements. To join two lists, we use the
		\lstinline:^^: operator. 
		
		To emulate the queue behaviour we need, we use a list of a color instead of
		using the actual color we want in that place. When we want to take an
		element from the front of the queue, we use the \lstinline-::- operator to
		bind the head and tail of the list to variables, and put only the tail back to
		the source place. When we want to append an element to a queue, we concatenate
		the queue using the \lstinline:^^: operator with a new list containing only
		the new element. To improve readability of the model, these queue operations
		have one arc slightly dimmed, to emphasise the flow direction of data.
		
		An example of this is seen on the Send data transition. On the left side, the
		list in the Messages to be sent place is bound to the two variables msg and
		msgs, and only msgs is put back. On the right side, we take the list in Send
		Client Messages and bind it to the variable msgs2, and send back a
		concatenation of this list and a new list containing msg, which was bound
		earlier in the incoming arc from Messages to be sent. The total effect is that
		we take the first element from Messages to be sent, and add it to the end of
		the list in Send Client Message.

	\subsubsection{Program Flow}
	
		The Request connection transition at the top is highlighted by a green border,
		which means that it is enabled and ready to fire. If we were to fire this transition,
		it would consume the \lstinline:STRING: token, named s, produce a
		\lstinline:MESSAGE: token containing s, and add it to the queue in the Send
		Client Message place.
		
		Next, the Client Application waits for a \lstinline:CONN_RESULT: token, and if
		this is equal to \lstinline:success:, we add a \lstinline:UNIT: token to the
		Active Connection place. If any other messages are received before this, they
		will wait at the Receive Client Event place, since the Receive Data transition
		will not fire unless the Active Connection place has a \lstinline:UNIT: token.
		
		If and when the Active Connection place has a \lstinline:UNIT: token, the
		Client Application can start sending and receiving messages. A sample of
		messages has been predefined at the Messages to be sent place, but this would
		probably be dynamic in a real application.
		
		Finally, if the Client Application receives a \lstinline:MESSAGE: where the
		\lstinline:OPERATOR: is \lstinline:CLOSE:, nothing is put back into the Active
		Connection place, and the connection is effectively closed. 

\subsection{Client WebSocket Library}

	\fig{ClientWebSocket.eps}{The Client WebSocket Library}{client_wslib}

	This page consists mostly of subpages. The only processing being done directly
	on this page is masking of all websocket frames, which is required from the
	client by the protocol specification. The rest is plumbing between the
	subpages.
	
	The new colorsets are for HTTP requests and responses, WebSocket frames, and
	packets.
	
	\begin{lstlisting}[label=lst:client_lib_colset,caption=Client library color
	sets]
	colset HTTP_VERB = union
	GET + POST + PUT + DELETE + HEAD;
	
	colset REQUEST_LINE = record
	Verb: HTTP_VERB *
	Path: STRING *
	Version: STRING;
	
	colset HTTPREQ = record
	RequestLine: REQUEST_LINE *
	Headers: HEADERS;
	
	colset RESPONSE_LINE = record
	Version: STRING *
	Status: INT *
	Message: STRING;
	
	colset HTTPRES = record
	ResponseLine: RESPONSE_LINE *
	Headers: HEADERS;
	
	colset PACKET = union 
	HttpReq:HTTPREQ + 
	HttpRes:HTTPRES +
	WsFrame:WSFRAME;

	colset PACKETLIST = list PACKET;
	\end{lstlisting}
	
	\subsubsection{New connection}
		
		\fig{NewConnection.eps}{New Connection subpage}{new_connection}
		
	\subsubsection{Process response}
		
		\fig{ProcessResponse.eps}{Process Response subpage}{process_response}
		
	\subsubsection{Wrap and send}
		
		\fig{WrapAndSend.eps}{Wrap And Send subpage}{wrap_and_send}
		
		Testkanin
		
		\paragraph{Fragment and queue}
			
			\fig{FragmentAndQueue.eps}{Fragment And Queue subpage}{fragment_and_queue}
			
			Quick text
		
	\subsubsection{Unwrap and receive}
		
		\fig{UnwrapAndReceive.eps}{Unwrap And Receive subpage}{unwrap_and_receive}
	
		
		\paragraph{Fragmented}
			
			\fig{Defrag.eps}{Defragment}{defragment}
			
			Quick text
			
\subsection{Connection}

	\fig{Connection.eps}{The Connection}{connection}
	
	Very little is happening here. The packets that come from the Client Send place
	go to the Server Receive page, and from the Server Send place to the Client
	Receive place. The transportation of data between the client and the server is
	assumed to be taken care of by TCP, as the WebSocket protocol specifies, and is
	not necessary to model in detail to show how WebSocket works.
	
	The packets are also not converted to pure bits or bytes. This decision was
	made to keep inspection easier during simulation. 

\subsection{The Server WebSocket Library}
	
	\fig{ServerWebSocket.eps}{The Server WebSocket Library}{server_wslib}
	
	The Server version of the WebSocket Library is very similar to the Client
	version. The main differences are that instead of masking outgoing frames, we
	are checking incoming frames for a mask and unmasking them, and that we are
	checking for incoming connections and replying to them based on what the Server
	Application decides.
	
	The Server Application can send two types of colorsets: \lstinline:MESSAGE: and
	\lstinline:CONN_REPLY:. A special colorset has been made to accomodate this,
	\lstinline:MSG_OR_CONN_REPLY:. 
	
	The Wrap and Send and the Unwrap and Receive substitution transitions are the
	same as the ones for the Client Library. To be more precise, the Client Library
	and Server Library both have instances of the same subpage, so that editing the
	subpage model affects both parent pages but simulating them lets them have
	different states.
	
	\subsubsection{Get Connection Request}
		
		\fig{ConnectionRequest.eps}{Get Connection Request}{connection_req}

	\subsubsection{Send Connection Response}
		
		\fig{ConnectionResponse.eps}{Send Connection Response}{connection_res}
		
\subsection{Server Application}
	
	\fig{ServerApplication.eps}{The Server Application}{server_app}
	
	The Server Application has three tasks: Accept or reject incoming connections,
	and send and retrieve data. A real world application would have more logic
	here, but the interface to the library would be the same.
