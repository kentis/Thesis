\chapter{Background}
\label{chap:background}



\section{Coloured Petri Nets}
Common usage: Process and protocol modeling, concurrent programming. Operations:
Simulation, verification and analysis. More recently also software design.

Short intro to places, transitions and arcs?

\section{CPN Tools}

Graphical tool used to design CPN models. 

Reference, with url. Screenshot?

\subsection{CPN ML}
	
	CPN Tools uses the CPN ML language to specify declarations and net inscriptions.
	This language is an extension of the functional programming language Standard
	ML, developed at Edinburgh University.

\subsection{Declarations}

\subsection{Inscriptions}

\section{WebSocket}

The primary case study for this thesis is the WebSocket
protocol \cite{draft-ietf-hybi-thewebsocketprotocol}. In this section the model
that has been built will be described in full detail.

\subsection{Overview}

\fig{Overview.eps}{Overview of CPN model of the WebSocket protocol}{overview}

Shown in \figref{overview} is the top-level Overview of the WebSocket
protocol as a CPN model.

Resembles part of OSI model (ref), where top level is levels 6 and 7, middle
level is level 5, and bottom level is levels 4 through 1. Two-way communication
between levels.

Circles represent places. They can contain tokens of a specified colour, and
can have markings to define initial tokens.

Double-bordered rectangles represent subpages. These are separate models that
have input and output places that connect to the places on their parent page. 
The subpages will examined in the following subsections.

The places in the Overview have the following color sets:

\begin{lstlisting}[label=lst:overview_colset,caption=Overview color sets]
colset OPERATION = union
CONNECT + TEXT + BINARY + 
PING + PONG + CLOSE;

colset MESSAGE = record
Op: OPERATION *
Message: STRING;

colset MESSAGES = list MESSAGE;

colset EVENT = union
Msg:MESSAGE +
ConnRequest +
ConnResult:CONN_RESULT;

colset EVENTS = list EVENT;

colset CONN_REPLY = bool with
(reject, accept);

colset MSG_OR_CONN_REPLY = union
Msg':MESSAGE +
ConnReply:CONN_REPLY;

colset MSGS_OR_CONN_REPLY 
= list MSG_OR_CONN_REPLY;

colset PACKET = union 
HttpReq:HTTPREQ + 
HttpRes:HTTPRES +
WsFrame:WSFRAME;

colset PACKETLIST = list PACKET;
\end{lstlisting}

A \lstinline:MESSAGE: consists of an \lstinline:OPERATION: and the
\lstinline:STRING: message body. We can also have a list of
\lstinline:MESSAGES: to keep them ordered. Lists will be explained in
detail later.

The client application sends \lstinline:MESSAGES: to the library and receives
\lstinline:EVENTS: back, which can be either a \lstinline:MESSAGE: or a
\lstinline:ConnReply:. The server application also receives \lstinline:EVENTS:,
but can send either a \lstinline:MESSAGE: or a \lstinline:CONN_REPLY:, which is
used for connection attempts. The \lstinline:CONN_REPLY: colorset is simply a
boolean value with different names for true and false, for improving readability
and semantics.

Both libraries send and receive \lstinline:PACKET:s. These are abstract and not
fully modeled or simulated actual network packets, as this is not relevant to
how WebSocket works.

\subsection{Client Application}

	\fig{ClientApplication.eps}{The Client Application}{client_app}
	
	Laid out from top to bottom to loosely show sequence. 
	
	Bottom places represent interface to WebSocket library. To simplify the overview
	model and facilitate easier later expansion, we have only two places that act as
	input and output. These are called Receive Client Events and Send Client
	Message, and are tagged In and Out respectively. These are connected to the
	respective places on the Overview, which are also connected to corresponding
	places in the WebSocket Library.
	
	
	\subsubsection{Variables}
	
	The arcs here have inscriptions on them containing variables. These are
	declared globally and can only be bound to colors of the colorset they are
	defined for. 
	
	
	
	\subsubsection{Queues}
	
	A lot of the places in this model rely on tokens being consumed in the same
	order they are produced, and to enforce this, queues are used, facilitated
	by lists. To describe a list in SML, we use \lstinline:[]: square brackets. By
	themselves they represent an empty list. To describe a populated list, we
	write each token inside the brackets separated by commas. An example of this
	is seen on the initial marking for the Messages to be sent place.
	
	To process such a list, we use the \lstinline-::- operator like this:
	\lstinline-head::tail-, where head is the first element in the list, and tail
	is all the following elements. To join two lists, we use the
	\lstinline:^^: operator. 
	
	To emulate the queue behaviour we need, we use a list of a color instead of
	using the actual color we want in that place. When we want to take an
	element from the front of the queue, we use the \lstinline-::- operator to
	bind the head and tail of the list to variables, and put only the tail back to
	the source place. When we want to append an element to a queue, we concatenate
	the queue using the \lstinline:^^: operator with a new list containing only
	the new element. To improve readability of the model, these queue operations
	have one arc slightly dimmed, to emphasise the flow direction of data.
	
	An example of this is seen on the Send data transition. On the left side, the
	list in the Messages to be sent place is bound to the two variables msg and
	msgs, and only msgs is put back. On the right side, we take the list in Send
	Client Messages and bind it to the variable msgs2, and send back a
	concatenation of this list and a new list containing msg, which was bound
	earlier in the incoming arc from Messages to be sent. The total effect is that
	we take the first element from Messages to be sent, and add it to the end of
	the list in Send Client Message.

	\subsubsection{Program Flow}
	
	The Request connection transition at the top is highlighted by a green border,
	which means that it is enabled and ready to fire. If we were to fire this transition,
	it would consume the \lstinline:STRING: token, named s, produce a
	\lstinline:MESSAGE: token containing s, and add it to the queue in the Send
	Client Message place.
	
	Next, the Client Application waits for a \lstinline:CONN_RESULT: token, and if
	this is equal to \lstinline:success:, we add a \lstinline:UNIT: token to the
	Active Connection place. If any other messages are received before this, they
	will wait at the Receive Client Event place, since the Receive Data transition
	will not fire unless the Active Connection place has a \lstinline:UNIT: token.
	
	If and when the Active Connection place has a \lstinline:UNIT: token, the
	Client Application can start sending and receiving messages. A sample of
	messages has been predefined at the Messages to be sent place, but this would
	probably be dynamic in a real application.
	
	Finally, if the Client Application receives a \lstinline:MESSAGE: where the
	\lstinline:OPERATOR: is \lstinline:CLOSE:, nothing is put back into the Active
	Connection place, and the connection is effectively closed. 

\subsection{Client WebSocket Library}

	\fig{ClientWebSocket.eps}{The Client WebSocket Library}{client_wslib}

	This page consists mostly of subpages. The only processing being done directly
	on this page is masking of all websocket frames.
	
		\subsubsection{New connection}
		
		\fig{NewConnection.eps}{New Connection subpage}{new_connection}
	
		
\subsection{Connection}

	\fig{Connection.eps}{The Connection}{connection}
	
	Very little is happening here. The packets that come from the Client Send place
	go to the Server Receive page, and from the Server Send place to the Client
	Receive place. The transportation of data between the client and server is
	assumed to be taken care of by TCP, as the WebSocket protocol specifies, and is
	not necessary to model in detail to show how WebSocket works.

\subsection{Server WebSocket Library}
	
	\begin{figure}
	\centering
	\includegraphics[scale=0.4]{figures/ServerWebSocket.eps}
	\caption{The Server WebSocket Library}
	\label{fig:server_wslib}
	\end{figure}
	
	The Server version of the WebSocket Library is very similar to the Client
	version. The main differences are that instead of masking outgoing frames, we
	are checking incoming frames for a mask and unmasking them, and that we are
	checking for incoming connections and replying to them based on what the Server
	Application decides.
	
	The Server Application can send two types of TODO:
	
	The Wrap and Send and the Unwrap and Receive substitution transitions are the
	same as the ones for the Client Library. To be more precise, the Client Library
	and Server Library both have instances of the same subpage, so that editing the
	subpage model affects both parent pages but simulating them lets them have
	different states.
	
	\subsubsection{Get Connection Request}
		
		\begin{figure}
		\centering
		\includegraphics[scale=0.4]{figures/ConnectionRequest.eps}
		\caption{Get Connection Request}
		\label{fig:connection_req}
		\end{figure}

	\subsubsection{Send Connection Response}
		
		\begin{figure}
		\centering
		\includegraphics[scale=0.4]{figures/ConnectionResponse.eps}
		\caption{Send Connection Response}
		\label{fig:connection_res}
		\end{figure}
		