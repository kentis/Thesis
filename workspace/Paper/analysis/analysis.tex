\chapter{Analysis and Design}
\label{chap:analysis}

\section{Requirements} \com{Finne på navn på plugin. ePNK CPN Pragma Plugin?}
Before we describe the Eclipse plugin that has been developed, we discuss the
requirements.
The requirements can be divided into four main classes:

\com{Mer detaljer}
\begin{itemize} 
	\item Importing models created in CPN Tools. 

	\item Annotate model with pragmatics. 
		
	\item Load sets of domain-specific pragmatics to make available for the model.
	
	\item Define set of model-specific pragmatics while annotating the model

\end{itemize}

\section{Defining Pragmatics}
\com{TODO: Detaljert info om pragmatikker og hva de er}

A Pragmatic is an annotation on a model element that describes how it should be
translated into code. Each pragmatic has restrictions on which model elements it
can annotate.

Pragmatics come in three types: General, domain-specific and model-specific.



\section{The CPN Ontology with Pragmatics}
As mentioned in section \ref{sec:ontologies}, Pragmatics are defined and modeled
as ontologies, using OWL 2 Web Ontology Language.  

There exists two ontologies that function as a base for pragmatics: One that
defines Colored Petri Nets, and one that defines base classes for pragmatics

\com{TODO: Beskrive ontologiene}

\section{The Annotated CPN model type for ePNK}
While designing the Type model for the Plugin, it was decided to separate it
into two parts: One to define CPN Type, and one for defining Annotated CPN Type,
extending from the first. This also adds the benefit that the pure CPN Type can
be used for other applications.

\com{Oppdater figurer! }
\fig{CPNDefinition.pdf}{CPN model type diagram}{cpn_model_diagram}
A custom Petri Net Type is made by first creating an Eclipse Plugin project. 
In this project, an EMF model should be created. This is the Type Model, and
should inherit the PNML Core Model from ePNK, or any other model that already
does this (such as the P/T-Net or HLPNG Types). \com{Glossary for P/T-Net and
HLPNG}

The CPN model, shown in \figref{cpn_model_diagram}, defines the structure and
constraints of Colored Petri Nets. The first thing this new Model Type should
define is a subclass of the PetriNetType class with the name of the new Model
Type, which in our case is CPN. This can be seen in the top left corner of the
diagram in \figref{cpn_model_diagram}. This class is what identifies the Type,
and is what will appear in the menu to let a user extend a model with the new
Type.
\com{add fig?}

After creating this model, EMF can generate source code for interfaces and
implementations of the new class. This is done by creating a ``genfile''
linked to the EMF model. The genfile can define metainfo such as the base
package of generated source files, and configuration parameters for the
individual classes. EMF can then generate different groups of code, but for a
ePNK Type we only need Model code and Edit code. the Model code includes
interfaces and corresponding basic implementations of the classes as well as
factories for instantiating them, while the Edit code contains classes for
presenting the Model code in an editor.

After generating the code for the Type Model, the source file for
the implementation of the PetriNetType subclass needs two minor modifications
to work with ePNK: The constructor must be made public (it is protected by
default), and the toString method must be implemented to conform to the
PetriNetType interface. This method should return a string that textually
represents the net type, usually simply its formal name.

\fig{plugin_manifest_1.png}{Plugin Manifest part 1}{plugin_manifest_1}
\fig{plugin_manifest_2.png}{Plugin Manifest part 2}{plugin_manifest_2}
Before ePNK will recognise the plugin and the Type model, the plugin manifest
needs to be edited to define this plugin as an extension to the
org.pnml.tools.epnk.pntd extension point of ePNK. All that is needed to
configure this is supplyting a unique id, a descriptive name, and the fully
qualified classpath to th ePetriNetType subclass. \figref{plugin_manifest_1} and
\figref{plugin_manifest_2} shows the finished configuration for the CPN model
type. \com{Kan bytte ut figurene med XML-data istedet}

EMF does not support merging of models, meaning it is not possible to define new
properties or relations directly on the original classes of the Core Model.
Thus, in order to change the functionality of existing classes such as Place,
Arc and Page, they have to be subclassed. ePNK will use reflection to check a
Type Model for subclasses with the same name as classes in the Core Type, and
load these dynamically instead of the base classes.
This can be seen in \figref{cpn_model_diagram}, where Place, Arc, Transition and Page are all
subclassed from the classes referenced from the Core Model, with added
attributes needed to represent Coloured Petri Nets.

TODO: Constraints

\fig{PragmaCPNDefinition.pdf}{Annotated CPN model type
diagram}{ann_model_diagram} 
The Annotated CPN model, shown in \figref{ann_model_diagram}, extends the CPN
model to enable annotation of model elements. It also handles saving and loading
of ontologies that define sets of pragmatics.

TODO: Intro Pragma Net Type

These subclasses then have references to the Pragma class. The references are
configured to act as containment, meaning Pragma instances are created as
children of the related classes. TODO: Smooth overgang. As we can see in
\figref{add_child_pragma_menu}, Pragma objects are now available as children to Places.

\fig[0.6]{ePNK_AddChildMenu.png}{Adding Pragma as child to
Place}{add_child_pragma_menu}

The Pragma class inherits from Label, which lets it be represented visually as a
text label in the graphical editor of ePNK.

\section{Importing from CPN Tools}
Access/CPN is a framework that can parse CPN models saved by CPN Tools and
represent the model with EMF classes. Access/CPN has many additional features
related to the semantics of CPN, but only the model importer is of relevance for
the work in this thesis.

Access/CPN also uses EMF to represent models internally. The EMF model for CPN
models that Access/CPN defines uses many of the same class names as ePNK, which
makes it tedious to write and read code working between the two frameworks due
to the need to use fully qualified classpaths to avoid name collisions.
Initially we planned to extract the parser source code from Access/CPN and
rewriting it to use the new ePNK CPN Type classes. This plan was later discarded in
favor of depending on the Access/CPN plugin, as Access/CPN has continually been
improved during development of the Plugin \com{Sett inn navn}, and is now also
capable of parsing graphics data. And by depending on Access/CPN instead of writing
our own parser, we can also benefit from further updates more easily.

The conversion is straightforward, the .cpn file is loaded with Access/CPN,
and the resulting model is then converted object by object to the ePNK CPN type.

\section{Creating annotations}
Labels on nodes, arcs and inscriptions. 
Choose from list. Possibly write freehand with content assist. Validation, with
problem markers (Eclipse feature).

\section{Choosing Pragmatics Sets}
Where to store? Model, Project, Plugin
Model pros:
	Will need anyway for model-specific pragmatics
	Could be associated with net type as a property (like HLPNG does) or as a sub
	node somewhere
	Have URI string and version to check.
cons:
	Keeping base pragmatics up to date a problem
Namespace-based? Already required for ontology


	\subsection{Creating custom pragmatics}
	Dynamically supported in content assist 
	If ontology-based, use SADL editor
	På sikt eget verktøy
		Hva kan det settes på, hvilke attributter har det.
		Oversette til ontologi

