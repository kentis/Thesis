\chapter{Analysis, Design and Implementation}
\label{chap:analysis}


After picking the technologies described in the previous chapter, since many of
the componets have Eclipse in common, it was an easy decision to develop
\thename{} as an Eclipse plugin. This also let us centralise all our development
in Eclipse.

Our analysis of available software solutions and platforms showed that the basic
primitives that are required to develop the desired code generation pragmatic
framework are available as part of the Eclipse eco system. It is therefore
natural to develop \thename{} as an Eclipse Plugin and base all software
develpoment in the context of this thesis on the Eclipse Platform.

Note that both Access/CPN and ePNK use the term Page instead of Module, so for
convenience we have done the same in the implementation of \thename{}.

\section{The CPN Ontology with Pragmatics}

As mentioned in section \ref{sec:ontologies}, Pragmatics are defined and modeled
as ontologies, using OWL 2 Web Ontology Language.  

There exists two ontologies that function as a base for pragmatics: One that
defines Coloured Petri Nets, and one that defines basic classes for pragmatics

\lstinputlisting[label=lst:cpn.owl,numbers=left,stepnumber=5,
caption=The CPN Ontology]
{D:/Documents/Master/Thesis/workspace/Ontologies/ontologies/cpn.fowl}


Every ontology must be declared with |Ontology()| containing an
Internationalized Resource Identifier (IRI) and a series of declarations and
axioms. IRI is a generalization of the Uniform Resource Identifier (URI) to
allow all Unicode characters to be used. An IRI can point to an actual resource
on the internet, but is not required to do so. Each concept in an ontology is
also identified with an IRI, but to avoid reprtition we define ``:`` as a prefix
representing this document's IRI. Prefixes can also be declared for other
ontologies, and some (like owl: and xsd:) are predefined.

Inside the |Ontology()| declaration we write declarations and axioms to describe
the domain. Whitespace and indentation is syntactically irrelevant and only used
for readability. We first declare the class |:ColouredPetriNet|. We then declare
the object property |:pages|, and restrict its domain to |:ColouredPetriNet| and
its range to |:Page|. The class |:Page| is defined just below, but the order of
declaration is not important, as the whole document must loaded before any
processing or reasoning can be performed. Also note that there are two kinds of
properties: Object (which rnage must be a class) and Data (which range must be
a datatype primitive, like string or integer, as defined in the xsd: ontology).

We then continue declaring all model elements in a similar manner. We will
point out only new axiom types in the order they are declared, referencing them
by line number. 

Line 20 states |InverseObjectProperties(:page :elements)|, defining these
properties as inversely related. An example consequence of this is if we define
an individual :Element and specify its :page, it is implicitly known that the
:Page contains that individual in its :elements.

Line 23 states |SubClassOf(:Element ObjectMaxCardinality(1 :page))|, meaning an
:Element can have at most 1 :page.

Line 26 has a normal subclass axiom, defining that every :Node is a kind of
:Element.

Line 58-61 define three individuals |:In :InOut and :Out|. Line 61 means that
any instance of |:PortType| is restricted to these three individuals.

Line 96 declares the property |:codeSegment|, a feature in CPN Tools we have not
used, but include for completeness.

Lines 120-123 declare classes as disjoint. This is neccessary, as ontologies by
default use open world assumptions, meaning even though something is not
explicitly stated does not mean it isn't true. Thus, without these declarations,
it is possible for an individual to for instance be a :Place and an :Arc at the
same time. Thus, we need to ``close the world'' by defining classes as disjoint,
meaning a member of one class is never a member of any of the other classes in
the list.

Next, we show the basic framework ontology for pragmatics.

\lstinputlisting[label=lst:basic.owl,numbers=left,stepnumber=5,
caption=The Basic Pragmatics Ontology]
{D:/Documents/Master/Thesis/workspace/Ontologies/ontologies/basic.fowl}

An ontology document can import other ontologies by referring to their IRI.  We
describe later how this is taken into account when loading ontology documents
from projects and plugins. In this ontology we import the CPN Ontology and
assign it the prefix |cpn:|.

This ontology is much shorter, declaring only three new classes |:Pragmatic|,
|:Property| and |:Operation|, as well as their disjointness and properties. It
also adds the property |:hasPragmatic| to |cpn:Element|

Next, we have the ontology for Generic pragmatics.

\lstinputlisting[label=lst:nppn.owl,numbers=left,stepnumber=5,
caption=The Generic Pragmatics Ontology]
{D:/Documents/Master/Thesis/workspace/Ontologies/ontologies/generic/nppn.fowl}

This is the first ontology that defines actual usable pragmatics. The second
line of each pragmatic declaration is a form of property restriction. The first
one (line 14) states that a |:Principal| can only belong ot a |cpn:Page|.

The |:External| pragmatic (line 24 and 25) shows why ontologies are well suited
for defining pragmatics. It can belong to |:TransitionConnectedToId|, which is
defined as the last part of the document. We first define |:IdPlace| to be
anything that is a |cpn:Place| and has exactly one |:Id| pragmatic. We further
define |:ArcFromId| as anything that is a |cpn:Arc| coming from an |:IdPlace|.
Finally, a |:TransitionConnectedToId| must have an incoming |:ArcFromId|. All
together this forms a complex requirement that can easily be checked with the
help of a reasoner.

Refer to \cite{Simonsen2011} for further explanation?

\subsection{The Ontology Containment Project}
The ontologies described above are not subject to change by the user, and will
always be used when annotating a model. We need a way to conveniently provide
them to the model, as well as utilities for managing them. For this purpose we
created a separate plugin called Ontologies. It contains the ontology documents,
utility classes for listing all ontologies the plugin provides, the
PluginIRIMapper which can translate the IRI of import statements to the ontology
documents available in the plugin, and the OntologyLoader, which creates a
manager and includes the PluginIRIMapper automatically.

It also includes the OWL API and HermiT jar files, and exports their packages to
let other plugins use them. This gives a central point of upgrading should it be
desired in the future.

\section{The Annotated CPN model type for ePNK}
While designing the Type model for the Plugin, it was decided to separate it
into two parts: One to define a CPN Type, and one for defining an Annotated CPN
Type, extending from the first. This also adds the benefit that the pure CPN
Type can be used for other applications.

A custom Petri Net Type needs to be contained in an Eclipse Plugin project.
Such a project will contain configuration files that define the properties and
capabilities of the plugin. These files include MANIFEST.MF for declaring plugin
name, version, dependencies etc, plugin.xml for defining extensions, extension
points etc, and build.properties for defining build parameters. However, the
Eclipse Plugin IDE includes an editor for editing all three files in a
convenient user interface with guides and content assistance.

After creating a plugin project, an EMF model should be created. This is the
Type Model, and should inherit the PNML Core Model from ePNK, or any other model
that already does this (such as the P/T-Net or HLPNG Types). \com{Glossary for
P/T-Net and HLPNG} We will refer to the PNML Core Model as the Core
Model.

\subsection{CPN Type}
The CPN model, shown in \figref{cpn_model_diagram}, defines the structure and
constraints of Coloured Petri Nets. The first thing this new Model Type should
define is a subclass of the PetriNetType class from the Core Model (we will
refer to this as the Core Type), with the name of the new Model Type, which in
our case is CPN. This can be seen in the top left corner of the diagram in
\figref{cpn_model_diagram}. This class is what identifies the Type, and is what
will appear in the menu to let a user extend a model with the new Type.
\com{Oppdater figurer! }
\fig{CPNDefinition.pdf}{CPN model type diagram}{cpn_model_diagram}


EMF does not support merging of models, meaning it is not possible to define new
properties or relations directly on the original classes of the Core Model.
Thus, in order to change the functionality of existing classes such as Place,
Arc and Page, they have to be subclassed. ePNK will use reflection to check a
Type Model for subclasses with the same name as classes in the Core Type, and
load these dynamically instead of the base classes.
This can be seen in \figref{cpn_model_diagram}, where Place, Arc, Transition and
Page are all subclassed from the classes referenced from the Core Model, with
added relations to inscription classes.

To represent the different inscriptions of a CPN model, we define classes that
inherit the Label class from the Core Model. From a data modeling
perspective, it would make more sense to make inscriptions simple
string attributes of the classes they belong to, but the Label class includes
functionality required for displaying in the graphical diagram editor of ePNK.
The different inscription classes are identical implementation-wise, but have
different names to be distinguishable in the user editor context menu for adding
child elements.

\subsection{Code generation}
After creating this model, EMF can generate source code for interfaces and
implementations of the new classes. This is done by creating a ``genfile''
linked to the EMF model. The genfile can define metainfo such as the base
package of generated source files, and configuration parameters for the
individual classes. EMF can then generate different groups of code, but for a
ePNK Type we only need Model code and Edit code. the Model code includes
interfaces and corresponding basic implementations of the classes as well as
factories for instantiating them, while the Edit code contains classes for
presenting and manipulating the model in an editor.

After generating the code for the Type Model, the source file for
the implementation of the PetriNetType subclass needs two minor modifications
to work with ePNK: The constructor must be made public (it is protected by
default), and the toString method must be implemented to conform to the
PetriNetType interface. This method should return a string that textually
represents the net type, usually simply its formal name.

Before ePNK will recognise the plugin and the Type Model, the plugin manifest
needs to be edited to define this plugin as an extension to the
org.pnml.tools.epnk.pntd extension point of ePNK. All that is needed to
configure this is supplyting a unique id, a descriptive name, and the fully
qualified classpath to th ePetriNetType subclass. \figref{plugin_manifest_1} and
\figref{plugin_manifest_2} shows the finished configuration for the CPN model
type. \com{Kan bytte ut figurene med XML-data istedet, skal jeg det?}
\fig{plugin_manifest_1.png}{Plugin Manifest part 1}{plugin_manifest_1}
\fig{plugin_manifest_2.png}{Plugin Manifest part 2}{plugin_manifest_2}

\subsection{Constraints}

We define one constraint for the CPN Type: An Arc must go between a Place and a
Transition. The mechanic for defining this is the EMF extension point
``org.eclipse.emf.validation.constraintProviders''. There are several ways of
extending this point, some of which are explained in \cite{kindler2011epnk}. Our
extension is shown in listing \lstref{constraintextension}. The class
ArcSourceAndTargetLimitation that implements the model checking is shown in
\lstref{constraintimpl}.

\begin{lstlisting}[language=XML,label=lst:constraintextension,float,
caption=constraintProvider extension] 
   <extension
         point="org.eclipse.emf.validation.constraintProviders">
      <category
            id="org.pnml.tools.epnk.validation"
            name="CPN Validation">
      </category>
      <constraintProvider
            cache="true"
            mode="Batch">
         <package
               namespaceUri="http://org.pnml.tools/epnk/pnmlcoremodel">
         </package>
         <constraints
               categories="org.pnml.tools.epnk.validation">
            <constraint
                  class="org.cpntools.pragma.epnk.pnktypes.cpndefinition.validation.ArcSourceAndTargetLimitation"
                  id="org.cpntools.pragma.epnk.pnktypes.cpndefinition.validation.ArcSourceAndTargetLimitation"
                  isEnabledByDefault="true"
                  lang="Java"
                  mode="Batch"
                  name="Arc source and target limitation"
                  severity="ERROR"
                  statusCode="301">
               <target
                     class="Arc:http://org.cpntools/pragma/epnk/pnktypes/cpndefinition">
               </target>
               <description>
                  An Arc must go between a Place and either a Transition or a Page.
               </description>
               <message>
                  The source and target of arc {0} are not compatible.
               </message>
            </constraint>
         </constraints>
      </constraintProvider>
   </extension>
\end{lstlisting}

\begin{lstlisting}[language=Java,label=lst:constraintimpl,float,
caption=Constraint Implementation]
public class ArcSourceAndTargetLimitation extends AbstractModelConstraint {
	public IStatus validate(IValidationContext ctx) {
		EObject eObj = ctx.getTarget();
		if (eObj instanceof Arc) {
			Arc arc = (Arc) eObj;
			Node source = arc.getSource();
			Node target = arc.getTarget();
			
			if (source != null && target != null) {
				PlaceNode pn = null;
				Node other = null;
				if(source instanceof PlaceNode) {
					pn = (PlaceNode) source;
					other = target;
				} else if (target instanceof PlaceNode) {
					pn = (PlaceNode) target;
					other = source;
				}
				if(	pn == null || // there was no Place
					other instanceof PlaceNode) // both are Places
					return ctx.createFailureStatus(new Object[] {arc});
			} 
		} 
		return ctx.createSuccessStatus();
	}
}
\end{lstlisting}

\subsection{Annotated CPN Type}
The Annotated CPN model, shown in \figref{ann_model_diagram}, extends the CPN
model to enable annotation of model elements. It also handles references
to ontology documents that define sets of pragmatics.

\fig{PragmaCPNDefinition.pdf}{Annotated CPN model type
diagram}{ann_model_diagram} 

As with the CPN Type Model, we have subclassed the classes of model elements we
need to extend. All of these need to be extended to support the same feature:
Being annotated with pragmatics. Ideally, we would have extended a superclass of
these classes, for instance Node. But this will not work, since model merging is
not possible (as discussed earlier), and subclassing Node will not work, since
existing classes will not be subclasses of our new superclass and therefore not
inherit anything from it. BELIEVE ME I TRIED HAHAHAHAHA *cough*

We needed to devise a way to extend a group of classes without access to their
superclass, and ideally without copying code between the classes. The solution
was to define an interface that all of the target classes implement. This is the
OntologyMember interface. It defines an operation for getting the OWL Class of
an instance, and since the ontology has been defined with the same names as the
EMF model, this is in most cases equal to the class name. \com{OBS getOWLClass
er ikke i bruk}

OntologyMember has a reference to the Pragma class. The reference is
configured to act as containment, meaning Pragma instances are created as
children of OntologyMember instances. A Pragma instance is a pragmatic, and is
defined by the IRI from the ontology, set in the text attribute. Like the
inscriptions from the CPN Type, Pragma inherits the Label class to be able to
display in the diagram editor.

\subsection{Remembering Pragmatics Sets}
We've already shown how pragmatics sets can be defined using ontology documents.
But we also need a way to include them in the models we want to annotate.
In other words: a model needs to store which pragmatic sets it utilises. This is
encapsualted in the OntologyDocument class, which can store the IRI of the
ontology and the path to the document that contains it. This is sufficient to be
able to reload the ontology if the model is closed and later reopened.

These OntologyDocument instances need to be serialised somewhere in the model.
Our first thought was to model them as contained by the PragmaCPN class (i.e.
the Type), however due to the fact that this element is serialised only as an
attribute this was not possible. We decided to create a new class which instance
is contained by the PetriNet class. This is the PragmaticsOntology class, and
the intention is to have a central entity to manage the ontologies of the entire
net, including loading and reasoning. For these purposes we defined one property
to contain the OWL API ontology manager, as well as two operations for including
new ontology documents and deduce which pragmatics are valid for a given
OntologyMemeber.

\subsection{Adding Pragmatics Sets}\label{sec:menufirsttime}
There needs to be a convenient way to add pragmatics sets to a model from
ontology documents. We decided to extend the context menu of the
PragmaticsOntology class for this purpose. 

Eclipse defines several extension points for extending every part of the UI.
Menus in particular have more than one way of being extended. The ePNK manual
suggests using the |org.eclipse.ui.popupMenus| extension point and has an
example of how to implement such an extension. By following this example we have
created the menu command ``Add Ontology'' under the submenu Pragmatics. The
extension is listed in \lstref{addOntologyMenu}. 

\begin{lstlisting}[language=XML,float,label=lst:addOntologyMenu,
caption=Add Ontology Menu Extension]
   <extension
         point="org.eclipse.ui.popupMenus">
      <objectContribution
            adaptable="false"
            id="ePNK Annotated CPN Type.edit.objectContribution1"
            objectClass="org.cpntools.pragma.epnk.pnktypes.pragmacpndefinition.PragmaticsOntology">
         <menu
               id="org.cpntools.pragma.epnk.pnktypes.pragmacpndefinition.actions.standardmenu"
               label="Pragmatics"
               path="additions">
            <separator
                  name="group1">
            </separator>
         </menu>
         <action
               class="org.cpntools.pragma.epnk.pnktypes.pragmacpndefinition.menu.AddOntologyAction"
               enablesFor="1"
               id="org.cpntools.pragma.epnk.pnktypes.pragmacpndefinition.actions.AddOntologyAction"
               label="Add Ontology"
               menubarPath="org.cpntools.pragma.epnk.pnktypes.pragmacpndefinition.actions.standardmenu/group1">
         </action>
      </objectContribution>
   </extension>
\end{lstlisting}

Every menu contribution should supply an |id| attribute to allow it to be
referenced by external code. This is the case for all the elements in this
listing, so we explain it here to avoid repetition.

The extension defines an
|<objectContribution>| element, stating that this menu item should only appear
in the context menu when an object of the specified type is selected. The
|adaptable| attribute is only relevant to IResource objects, but is a required
attribute qith a default value of false. The |objectClass| is the
target class that will have its context menu include the new menu, in this case
our PragmaticsOntology class.

We then define a |<menu>| element that will create a submenu intended to group
together all menu contributions related to pragmatics. The |label| is simply
the label, and |path| specifies where in the parent menu it should be
placed, whith the value ``additions'' being recommended. The menu has a
|separator| child element that acts as an anchor for positioning items. 

Last, there is the |action| element, defining the menu item that performs the
action. It specifies the |class| that performs an action, which should be a
class implementing the IObjectActionDelegate interface. We have implemented this
as the |AddOntologyAction| class, described below. The |enablesFor| attribute
specifies that the actionis enabled (clickable) when exactly 1 element is
selected. |label| is the displayed label. |menubarPath| defines
placement by referencing the |id| and |separator| we defined for |<menu>|.

A screenshot of the resulting menu is shown in \figref{addOntologyMenu}. As soon
as the menu should be displayed, an |AddOntologyAction| instance will be created
and configured with |setActivePart()| (which allows us to
get the current shell to be able to display error messages)
and |selectionChanged()| (which gives us the current model selection). These two
methods are shown in \lstref{AddOntologyAction_config}.

\fig{AddOntologyMenu.png}{Add Ontology Menu}{addOntologyMenu}

\begin{lstlisting}[language=Java,float,label=lst:AddOntologyAction_config,
caption=AddOntologyAction setActivePart() and selectionChanged()]
	private PragmaticsOntology ontology;
	private Shell shell;

	@Override
	public void selectionChanged(IAction action, ISelection selection) {
		ontology = null;
		if (selection instanceof IStructuredSelection) {
			IStructuredSelection structuredSelection = (IStructuredSelection) selection;
			if (structuredSelection.size() == 1
					&& structuredSelection.getFirstElement() instanceof PragmaticsOntology) {
				ontology = (PragmaticsOntology) structuredSelection.getFirstElement();
			}
		}
		action.setEnabled(ontology != null);
	}

	@Override
	public void setActivePart(IAction action, IWorkbenchPart targetPart) {
		shell = targetPart.getSite().getWorkbenchWindow().getShell();
	}
\end{lstlisting}

When the menu item is clicked, the |run()| method will be called, shown in
\lstref{AddOntologyAction_run}. This method will open the file selection dialog
shown in \figref{addOntologyDialog}. This dialog shows the current project's
resources and asks the user to select an ontology document. It does not filter
files on their extension, as there exist editors that save ontologies with
different extensions than those defined by W3C.

\begin{lstlisting}[language=Java,float,label=lst:AddOntologyAction_run,
caption=AddOntologyAction run()]
	@Override
	public void run(IAction action) {
		ElementTreeSelectionDialog dialog = new ElementTreeSelectionDialog(
				shell, new WorkbenchLabelProvider(),
				new BaseWorkbenchContentProvider());
		dialog.setTitle("Select an Ontology");
		dialog.setMessage("Select the Ontology document you want to include in the net:");
		
		dialog.setInput(getProject(ontology));
		dialog.open();

		if (dialog.getReturnCode() == Window.OK) {
			Object o = dialog.getFirstResult();
			if (o instanceof IFile) {
				IFile f = (IFile) o;
				ontology.addOntologyFromFile(f);
			} else {
				IStatus status = new Status(IStatus.ERROR, "PragmaCPN", 0,
						"Invalid file", null);
				ErrorDialog.openError(shell, "Invalid file",
						"The selected file was not valid.", status);
			}
		}
	}
\end{lstlisting}
\fig{AddOntologyDialog.png}{Add Ontology Dialog}{addOntologyDialog}

If the user selects a file and clicks OK, the |run()| method continues by
calling |addOntologyFromFile()| on the selected |PragmaticsOntology|.


\section{Importing from CPN Tools}
Access/CPN is a framework that can parse CPN models saved by CPN Tools and
represent the model with EMF classes. Access/CPN has many additional features
related to the semantics of CPN, but only the model importer is of relevance for
the work in this thesis.

Access/CPN also uses EMF to represent models internally. The EMF model for CPN
models that Access/CPN defines uses many of the same class names as ePNK, which
makes it tedious to write and read code working between the two frameworks due
to the need to use fully qualified classpaths to avoid class name collisions.
Initially we planned to extract the parser source code from Access/CPN and
rewriting it to use the new ePNK CPN Type classes. This plan was later discarded
in favor of depending on the Access/CPN plugin, as Access/CPN has continually
been improved during development of \thename{}, and is now also capable of
parsing graphics data. And by depending on Access/CPN instead of writing our own
parser, we can also benefit from further updates more easily.

The Eclipse Plugin IDE includes several template plugin projects, and one of
them is for creating an Import Wizard, that is a step-by-step dialog for
importing resources into the Eclipse workbench, for instance copying a file from
the file system to a project, or importing entire projects from version control.
The template also preconfigures the plugin manifest with an extension that makes
the wizard available in Eclipse's Import Dialog. This is shown in
\figref{import_wizard}

The import wizard for importing CPN Tools models only has one step, which
requires the user to select the .cpn file from the file system, and select a
destination in the workspace for the converted model. It is shown in
\figref{import_wizard}. AFter selecting the source file, the wizard suggests a
new name for the converted model based on the original file name but with the
.pnml extension.
\fig{import_wizard.png}{Import Wizard}{import_wizard}

The conversion process is straightforward, the .cpn file is loaded with
Access/CPN, and the resulting model is then converted object by object to the
ePNK Annotated CPN type. The final model also includes a PragmaticsOntology
instance.

\section{Creating Pragmatic Annotations}
We want it to be fast and easy to annotate model elements, and an immediate
example to follow is the way child and sibling elements are added to the model
through context menus. It is possible to create an empty Pragma instance as a
child of an OntologyMember instance without any manual programming; ePNK and EMF
dynamically takes care of that. The user can then manually enter the IRI of the
desired pragmatic.

Our vision was to provide a new menu entry next to New Child and New
Sibling that is dynamically populated with all valid pragmatics for the selected
element.
We have partially achieved this goal through implementation in the PragmaticsOntology
class. It is capable of correctly classifying which pragmatics belong to which
model element, but can not make use of more advanced definitions (like the
previously discussed |:External| pragmatic). The routine for providing the menu
entry can be divided into three parts, and we will explain each part in the
following subsections.

	\subsection{Providing a Dynamic Context Menu}
	
	
	\subsection{Determining Appropriate Pragmatics}
	
	The algorithm we designed is na\"{\i}ve in its nature: Whenever the Add
	Pragmatics menu is opened, it will create a new manager and load every ontology
	from scratch. 
	
	EMF has an extensive notification framework for reacting to model changes, and
	it should be possible to leverage this to efficiently maintain an accurate
	ontology of the loaded CPN model. But as a proof of concept our approach is
	sufficient.
	
	\subsection{Creating the Pragma Model Element}
	
\section{Defining Model Specific Pragmatics Sets}
Creating a set of model specific pragmatics (or any set of pragmatics) is as
simple as writing an ontology for it, but this isn't easy if you're not already
familiar with ontologies and the OWL 2 specification and syntaxes. There exist
a number of tools for writing ontologies, 

Dynamically supported in content assist 
If ontology-based, use plugin editor
	
A specialised tool for creating model specific pragmatics would have ben ideal.
Such a tool would give simple mechanics using GUI controls for specifying which
model elements a pragmatic can be attached to, and which parameters it has. The
Plugin Manifest editor is a good example of what we have in mind. However, this
could not be included for this thesis due to time constraints.
	
