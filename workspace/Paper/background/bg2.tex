\chapter{Background}\com{BÃ¸r kanskje gjenvurdere om det skal hete
``Background''}
\label{chap:background}

\section{The WebSocket Protocol}
The primary case study for this thesis is the WebSocket protocol 
\cite{draft-ietf-hybi-thewebsocketprotocol}. From the abstract of the document:
\begin{quote}The WebSocket protocol enables two-way communication between a
client running untrusted code running in a controlled environment to a
remote host that has opted-in to communications from that code.
\end{quote}

\fig[0.4]{WebSocketSequenceDiagram.pdf}{Sequence Diagram of the WebSocket
protocol}{wssequence}

\figref{wssequence} shows the basic sequence of the WebSocket protocol. To
establish a connection, a client sends a specially formatted HTTP request to a
server, which replies with a HTTP response. Once the connection is
established, the client and server can then freely send WebSocket message
frames, until either endpoint sends a control frame with the opcode 0x8 for
close and optionally data about the reason for closing. The other endpoint then
replies with the same opcode and data, and the connection is considered closed.

From the RFC document:

\begin{quote}
	Conceptually, WebSocket is really just a layer on top of TCP that
	does the following:
	\begin{itemize}
		\item adds a Web "origin"-based security model for browsers
	
		\item adds an addressing and protocol naming mechanism to support
		multiple services on one port and multiple host names on one IP
		address;
	
		\item layers a framing mechanism on top of TCP to get back to the IP
		packet mechanism that TCP is built on, but without length limits
	
		\item includes an additional closing handshake in-band that is designed
		to work in the presence of proxies and other intermediaries
	\end{itemize}
\end{quote}

\section{Coloured Petri Nets}

Common usage: Process and protocol modeling, concurrent programming. Operations:
Simulation, verification and analysis. More recently also software design.

The structure of CPN models will be explained gradually through the case study 

\subsection{CPN Tools}

Graphical tool used to design CPN models. 

\begin{comment}

\subsection{CPN ML}
	


		
		The simple types available are unit, boolean, integer, string, enumerated
		and index. A unit can have one value: \lstinline:():. Enumerated colour sets
		can have specified values, while index colour sets define an indexed range of
		values. 
		
		The compound types are:
		\begin{description}
		\item[Product] A combination of colour sets separated by \lstinline:*:. The
		postal code and city example from earlier would be
		\lstinline:product INT*STRING:, and a colour would be (5055,''Bergen'');
		\item[List] A list of items that belong to the same colour set.
		\item[Record] Similar to a product, but each element is named. The postal code
		and city example would give \lstinline-record Code:INT*City:STRING- and a
		colour would be \lstinline:{Code=5055,City="Bergen"}:
		\item[Union] This is used if a place should be able to contain colours from
		different colour sets, or if such colours should be handled in the same way at a
		point in the model. They can also contain simple identifiers, like an
		enumeration. An example is shown in Listing \ref{lst:overview_colset}.
		\end{description}
		
		For full syntax definition, please refer to the CPN Tools
		documentation. (ref?)

\end{comment}
\section{The WebSocket CPN Model}

The websocket protocol is the primary case study of this thesis. 
In this section the model that has been built is described in full detail.

\subsection{Overview}

	\fig{Overview.eps}{Overview of CPN model of the WebSocket protocol}{overview}
	
	\figref{overview} shows the top-level Overview module of the WebSocket
	CPN model.
	
	The model has been laid out to resemble part of the OSI model \cite{osi7}, where
	Client Application and Server Application each correspond to the top two
	layers Application and Presentation, Client WebSocket and Server WebSocket
	correspond to the Session layer, and Connection corresponds to the lower layers
	Transport, Network, Data Link and Physical.
	
	\subsubsection{Model basics}
	A Petri Net model consist of pages, or modules, that contain Places,
	Transitions and Arcs.
	
	Places are represented by circles. They can contain colours from a specified
	colour set, and have markings to define initial colour(s).  As an example, in
	the lower right we have the Server Send place. This place can have
	\lstinline:PACKETLIST: color tokens, and has an initial marking of an empty
	list \lstinline:[]:. It currently has one colour shown in the green box,
	\lstinline:1`[]:, which means one of an empty list. The number in the circle
	shows the total number of colours in this place.
	
	A colour can mean a single value like the integer 3, the string ``Hello'' or
	simple units which resemble Tokens from regular Petri Nets. A colour set is a
	set of such colours, for example all integers, the integers from 1 to 100, all
	lowercase letters, or all strings of length 5. These are examples of simple
	colour sets, as they each consist of basic data types. Compound colour sets are
	made by combining the simple ones in different ways to create data structures, for
	example an integer together with a string might describe a postal code and
	city. This will be described in more detail in the next section.
	
	Transitions are represented by rectangles. 
	
	Double-bordered rectangles represent substitution transitions which are bound
	to sub-modules. These are separate modules that have input and output places
	that connect to the places on their parent module. This enables us to keep
	the model structured and readable, and also allows reuse of modules in
	different parts of the model by instancing them, which will be described toward
	the end of the chapter. The details of each submodule is described in the
	following subsections.
	
	Arcs are directed arrows going between a place and a transition.
	
	The State of the model is defined by the current colors in
	each place. A Transition can consume colors from places if there is an arc from
	the place to the transition, and produce new colors in places where there is an
	arc from the transition to the place. This changes the state of the system.
	
	
	\subsubsection{Declarations}
	
	CPN Tools uses the CPN ML language to specify declarations and net inscriptions.
	This language is an extension of the functional programming language Standard
	ML, developed at Edinburgh University.
	
	All coloursets, variables, symbolic constants and functions have to be declared
	before they are used in the model. In CPN Tools these declarations can be
	grouped together, but they are still parsed sequentially, so if one declaration
	depends on another, it has to be declared after its dependency.

	Colour sets are defined with the following syntax:
	
	\lstinline:colset name = <type-specific>;:
	
	Names are always capitalised in this thesis, but any CPN ML identifier is
	valid.
	
	The places in the Overview use the following colour set definitions:
	
	\begin{lstlisting}[label=lst:overview_colset,caption=Overview colour
	sets,gobble=1]
	colset OPERATION = with CONNECT | TEXT | BINARY | PING | PONG | CLOSE;
		
	colset MESSAGE = record Op: OPERATION *	Message: STRING;
	
	colset MESSAGES = list MESSAGE;
	
	colset CONN_RESULT = bool with (fail, success);
	
	colset EVENT = union Msg:MESSAGE + ConnRequest + ConnResult:CONN_RESULT;
	
	colset EVENTS = list EVENT;
	
	colset CONN_REPLY = bool with (reject, accept);
	
	colset MSG_OR_CONN_REPLY = union Msg':MESSAGE + ConnReply:CONN_REPLY;
	
	colset MSGS_OR_CONN_REPLY = list MSG_OR_CONN_REPLY;
	
	colset PACKET = union HttpReq:HTTPREQ + HttpRes:HTTPRES + WsFrame:WSFRAME;
	
	colset PACKETLIST = list PACKET;
	\end{lstlisting}
	
	The \lstinline:OPERATION: colour set is an enumeration that represents the
	different types of messages that can be passed between the application and the
	protocol layer. All of these correspond with opcodes
	used in WebSocket frames, except \lstinline:CONNECT: which is used for
	initiating a connection.
	
	A \lstinline:MESSAGE: is a record that consists of an
	\lstinline:OPERATION: and the \lstinline:STRING: message body. Both
	data- and control-frames can have messages, although control-frame
	messages might not be shown to the user. Colours from record color sets can
	have their component colors referenced by name, in this case \lstinline:Op: and \lstinline:Message:. We can also have a list of \lstinline:MESSAGES: to keep them ordered. Lists will be explained in detail
	later where they are used and manipulated in the model.
	
	The WebSocket layer also needs a way to notify the application about connection
	results, which is done with the \lstinline:EVENT: color set. This is a union
	color set which can be either a \lstinline:MESSAGE:, a \lstinline:ConnRequest:
	identifier (with no other color associated), or a \lstinline:CONN_RESULT:. A
	union color set is used if a place should be able to contain colours from
	different colour sets, or if such colours should be handled in the same way at
	a point in the model. They can also contain simple identifiers (like
	\lstinline:ConnRequest:). And like \lstinline:MESSAGES: we can have a list of
	\lstinline:EVENTS.:
	
	The client application sends \lstinline:MESSAGES: to the WebSocket layer and
	receives \lstinline:EVENTS: back. The server application also receives
	\lstinline:EVENTS:, but can send either a \lstinline:MESSAGE: or a
	\lstinline:CONN_REPLY:, which is used for connection attempts. The
	\lstinline:CONN_REPLY: colourset is simply a boolean value with different
	names for true and false, for improving readability and semantics. A union of
	these two types must exist, \lstinline:MSG_OR_CONN_REPLY:, so the same place
	can be reused.
	
	TODO: Noe om hvorfor vi bruker kun en plass for dette
	
	Both the client and server WebSocket layers send and receive
	\lstinline:PACKET: colors, a union of three types of data. \lstinline:PACKET:s
	are abstract and not fully modeled actual network packets, as this is not
	relevant to how WebSocket works. Ther list version \lstinline:PACKETLIST: These
	color sets are described in the section for the Connection module.

\subsection{Client Application}

	\fig[0.4]{ClientApplication.eps}{The Client Application}{client_app}
	
	This module (\figref{client_app}) is laid out from top to bottom to loosely show
	the sequence of operation, as is most of the other modules.
	
	The places at the bottom represent the interface to the WebSocket layer. To
	simplify the overview model and facilitate easier later modification
	and expansion, we have only two places that act as input and output. These are
	called Receive Client Events and Send Client Message, and are tagged In and
	Out respectively. These are connected to the respective places on the
	Overview, which are also connected to corresponding places in the WebSocket
	Library.
	
	
	\subsubsection{Variables}
	
		The arcs here have inscriptions on them containing variables. Variables are
		declared globally and can only be bound to colours of the colourset they are
		defined for. 
		
		When a transition fires, it will bind the tokens it is consuming to the
		variables of the inscriptions on the arcs from the respective places. These
		variables can then be used to produce new tokens, by direct manipulation
		and/or in conditional statemens. The expression that will produce the desired
		result is inscribed on the output arc. 
		
		A set of variables has been declared for the simple coloursets as follows:
		
		\begin{lstlisting}[label=lst:standard_vars,caption=Simple Colourset Variables]
		var u, u1, u2, u3: UNIT;
		var b, b1, b2, b3: BOOL;
		var i, j, k: INT;
		var s, s1, s2, s3: STRING;
		var ss, ss1, ss2: STRINGLIST;
		\end{lstlisting}
		
		Several variables for the same coloursets have been created for convenience in
		the cases where colours of the same type is consumed from different places. If the same variable was
		used on each arc from two different places, both places would need a token
		with the same value. 
		
		Variable declarations will be listed as they are encountered in the model.
		As a general guideline, most variables are named with the first letter of its
		colourset for non-lists, and the same letter plus the letter s for lists. On
		this submodule we have the following variables:
		
		\begin{lstlisting}[label=lst:client_app_vars,caption=Client Application
		Variables]
		var msg: MESSAGE;
		var msgs, msgs2: MESSAGES;
		var es: EVENTS;
		\end{lstlisting}
	
	\subsubsection{Queues}
	
		A lot of the places in this model rely on tokens being consumed in the same
		order they are produced, and to enforce this, queues are used, facilitated
		by list colour sets. To describe a list in SML, we use square
		brackets \lstinline:[ ]:. By themselves they represent an empty list. To describe a populated list, we
		write each token inside the brackets separated by commas. An example of this
		is seen in \figref{client_app} on the initial marking for the
		\lstinline:Messages to be sent: place.
		
		To process such a list, we use the \lstinline-::- operator like this:
		\lstinline-head::tail-, where head is the first element in the list, and tail
		is all the following elements. To concatenate two lists, we use the
		\lstinline:^^: operator. 
		
		To emulate the queue behaviour we need, we use a list of a colour instead of
		using the actual colour we want in that place. When we want to take an
		element from the front of the queue, we use the \lstinline-::- operator to
		bind the head and tail of the list to variables, and put only the tail back to
		the source place. When we want to append an element to a queue, we concatenate
		the queue using the \lstinline:^^: operator with a new list containing only
		the new element. To improve readability of the model, these queue operations
		have one arc slightly dimmed, to emphasise the flow direction of data.
		
		An example of this is seen in \figref{client_app} on the arc
		from the \lstinline:Send data: transition to the 
		\lstinline:Messages to be sent: place. On the left side, the list in the
		Messages to be sent place is bound to the two variables msg and msgs, and only
		msgs is put back. On the right side, we take the list in Send Client Messages
		and bind it to the variable \lstinline:msgs2:, and send back a concatenation
		of this list and a new list containing msg, which was bound earlier in the incoming arc
		from Messages to be sent. The total effect is that we take the first element
		from Messages to be sent, and add it to the end of the list in Send Client
		Message.

	\subsubsection{Program Flow}
	
		The Request connection transition at the top is highlighted by a green border,
		which means that it is enabled and ready to fire. If we were to fire this transition,
		it would consume the \lstinline:STRING: token, named s, produce a
		\lstinline:MESSAGE: token containing s, and add it to the queue in the Send
		Client Message place.
		
		Next, the Client Application waits for a \lstinline:CONN_RESULT: token, and if
		this is equal to \lstinline:success:, we add a \lstinline:UNIT: token to the
		Active Connection place. If any other messages are received before this, they
		will wait at the Receive Client Event place, since the Receive Data transition
		will not fire unless the Active Connection place has a \lstinline:UNIT: token.
		
		If and when the Active Connection place has a \lstinline:UNIT: token, the
		Client Application can start sending and receiving messages. A sample of
		messages has been predefined at the Messages to be sent place, but this would
		probably be dynamic in a real application. \com{Kanskje dette kunne vÃ¦rt mer
		abstrakt? Argument for hvorfor modellert pÃ¥ denne mÃ¥ten.}
		
		Finally, if the Client Application receives a \lstinline:MESSAGE: where the
		\lstinline:OPERATOR: is \lstinline:CLOSE:, nothing is put back into the Active
		Connection place, and the connection is effectively closed. 

\subsection{The Client WebSocket Module}

	\fig{ClientWebSocket.eps}{The Client WebSocket Module}{client_wslib}

	This module consists mostly of substitution transitions. The only processing
	being done directly on this module is masking of all websocket frames
	\com{Hvordan funker mask funksjonen?}, which is required from the client by the
	protocol specification.
	The rest is plumbing between the submodules.
	
	The new coloursets are for HTTP requests and responses, WebSocket frames, and
	packets. They have corresponding variables. 
	
	\begin{lstlisting}[label=lst:client_lib_colset,caption=Library colour
	sets,gobble=1]
	colset HTTP_VERB = union GET + POST + PUT + DELETE + HEAD;
	
	colset REQUEST_LINE = record
	Verb: HTTP_VERB *
	Path: STRING *
	Version: STRING;
	
	colset HEADER = product STRING*STRING;
	
	colset HEADERS = list HEADER;
	
	colset HTTPREQ = record
	RequestLine: REQUEST_LINE *
	Headers: HEADERS;
	
	colset RESPONSE_LINE = record
	Version: STRING *
	Status: INT *
	Message: STRING;
	
	colset HTTPRES = record
	ResponseLine: RESPONSE_LINE *
	Headers: HEADERS;
	
	colset MASK = list BYTE with 4..4;
	
	colset MASKING = union
	Nomask + Mask:MASK;
	
	val opContinuation = 0x0;
	val opText = 0x1;
	val opBinary = 0x2
	val opConnectionClose = 0x8;
	val opPing = 0x9;
	val opPong = 0xA;
	
	colset WSFRAME = record
	Fin: BIT *
	Rsv1: BIT *
	Rsv2: BIT *
	Rsv3: BIT *
	Opcode: INT *
	Masked: BIT *
	Payload_length: INT *
	Masking_key: MASKING *
	Payload: STRING;
	
	colset WSFRAMES = list WSFRAME;
	
	colset PACKET = union 
	HttpReq:HTTPREQ + 
	HttpRes:HTTPRES +
	WsFrame:WSFRAME;

	colset PACKETLIST = list PACKET;
	\end{lstlisting}
	
	\begin{lstlisting}[label=lst:client_lib_vars,caption=Library
	variables,gobble=1]
	var wsframe: WSFRAME;
	var wsframes, wsframes2: WSFRAMES;
	var httpreq: HTTPREQ;
	var httpres: HTTPRES;
	var p: PACKET;
	var ps, ps1, ps2: PACKETLIST;
	\end{lstlisting}
	
	There are also static values declared here, which correspond to WebSocket
	frame operation identifiers.
	
	\subsubsection{New connection}
		
		\fig{NewConnection.eps}{New Connection submodule}{new_connection}
		
		This module is fairly straightforward. We take the first \lstinline:MESSAGE:
		in the list and create an HTTP request, which is then queued to be sent by the
		client, as well as keeping a copy of the request for validation purposes when
		the response arrives.
		
		The transition here has a guard inscription enclosed in square brackets. It is
		used for two things:
		The first line limits the transition to only accepting messages with the
		\lstinline:CONNECT:	operation, while the second line binds the url variable
		by parsing the string in the message into a \lstinline:URL:
		colour by using the \lstinline:parseurl(): function. This function makes use of
		a utility function \lstinline:split():  which splits a string on the first
		occurrence of a given character. To do this, it uses a recursive function
		\lstinline:split2(): to iterate over the characters. The functions have to be
		declared in reverse order to satisfy dependency.
		
		
		
		\begin{lstlisting}[label=lst:url,caption=URL Declarations,gobble=2]
		colset URL = record
		Protocol: STRING *
		Host: STRING *
		Port: INT *
		Path: STRING;
		
		var url: URL;
		
		fun split2 (s, t, i) =
		(* Recursively scan for character t in string s starting as position i, split
		if match *)
		  let
		    val ss = String.extract(s, i, NONE) 
		  in 
		    if String.isPrefix t ss then
		      [substring(s, 0, i), 
		      String.extract(s, i + String.size t, NONE)]
		    else split2(s, t, i+1)
		  end
		
		fun split (s, t) = 
		  (* Split string s on character c *)
		  if String.isPrefix t s then
		    [String.extract(s, String.size t, NONE)]
		  else if String.isSubstring t s then
		    split2 (s, t, 1)
		  else [s]
		
		fun parseUrl (s) = 
			let
			  val proto'rest = split (s, "://")
			  val proto'rest = 
			    if length proto'rest = 1 
			    then "ws" :: proto'rest 
			    else proto'rest 
			  val pro = List.hd(proto'rest)
			
			  val host'path = split (List.nth(proto'rest, 1), "/")
			  val pat = if length host'path = 2
			    then "/" ^ List.nth(host'path, 1)
			    else "/"
			  
			  val host'port = split (List.hd(host'path), ":")
			  val hos = List.hd(host'port)
			
			  val port'default = case pro of
			    "wss" => 443
			    | _ => 80
			  val por = if length host'port = 1 
			  then port'default
			  else let
			    val port'str = List.nth(host'port, 1)
			    val port'int'opt = Int.fromString port'str
			  in
			    Option.getOpt(port'int'opt, port'default)
			  end
			in
			  {Protocol=pro, 
			    Host=hos, 
			    Port=por, 
			    Path=pat}
			end;
		\end{lstlisting}
		
		The function httpReqFromUrl takes a URL argument and uses it to produce a
		HTTPREQ colour with headers according to the WebSocket protocol requirements.
		Not all headers defined by the protocol are used, because it is assumed this
		application is not browser based, and therefore specifying an origin does not
		make sense. \com{Skriv hvorfor det er en rimelig antagelse. (Det er det
		kanskje ikke)}
		
		\begin{lstlisting}[label=lst:httpReqFromUrl,caption=httpReqFromUrl,gobble=2]
		fun httpReqFromUrl (url:URL) = 
		{
		  RequestLine={
		    Verb=GET, 
		    Path=(#Path url),
		    Version=httpVersion
		  },
		  Headers=[
		    ("Host", (#Host url)),
		    ("Upgrade", "websocket"),
		    ("Connection", "Upgrade"),
		    ("Sec-WebSocket-Key", (B64 nonce)),
		    ("Sec-WebSocket-Version", "13")
		  ]
		};
		\end{lstlisting}
		
		
		
	\subsubsection{Process response}
		
		\fig{ProcessResponse.eps}{Process Response submodule}{process_response}
		
		On this module, the transition fires when a HTTPRES colour is received from the
		server (and the HTTPREQ colour from earlier is still waiting in its place). The
		boolean variable b is bound to the result from the isResponseValid function,
		which checks if the server's reply is valid and conforms to the WebSocket
		protocol specification.
		
		\begin{lstlisting}[label=lst:isResponseValid,caption=isResponseValid,gobble=2]
		fun isResponseValid (res:HTTPRES, req:HTTPREQ) = let
		  val rline = #ResponseLine res
		  val headers = #Headers res
		  val accepttoken = generateAccept(
		    getHeader("Sec-WebSocket-Key",
		      (#Headers req)))
		in
		  #Status rline = 101 andalso
		  getHeader("Upgrade", headers) 
		    = "websocket" andalso
		  getHeader("Connection", headers) 
		    = "Upgrade" andalso
		  getHeader("Sec-WebSocket-Accept",headers)
		    = accepttoken
		end
		\end{lstlisting}
		
		It sends the result directly to the Client App, and puts a token with colour
		\lstinline:CONN_OPEN: in the Active Connection place if b is true.
		
	\subsubsection{Wrap and send}
		
		\fig{WrapAndSend.eps}{Wrap And Send submodule}{wrap_and_send}
		
		This module takes new messages, wraps and optionally fragments them in the
		Fragment and queue submodule (explained below), and sends them if there is
		an open connection. If a Close frame is being sent,the
		connection state will be changed to \lstinline:CONN_CLOSING:, which prevents
		further sending.
		
		\paragraph{Fragment and queue}
			
			\fig{FragmentAndQueue.eps}{Fragment And Queue submodule}{fragment_and_queue}
			
			The top transition on this has two tasks: Making sure we do not process
			CONNECT messages, and filtering data and control frames into different
			places using the isData function. 
			
			\begin{lstlisting}[label=lst:isData,caption=isData,gobble=3]
			fun isData (msg:MESSAGE) =
			(#Op msg = TEXT) orelse
			(#Op msg = BINARY);
			\end{lstlisting}
			
			Control frames should never be fragmented, but data frames could be. This is
			taken care of by the fragment function, which also converts the message into
			a WSFRAME colour. The control frames are converted in the same way by the
			wrapmsg function. Both of these functions rely on the wrap function, and
			therefore have to be declared after it.
			
			
			\begin{lstlisting}[label=lst:fragment,caption=wrap wrapmsg and
			fragment,gobble=3]
			fun wrap (opc,payload,fin) = { Fin=fin,
			  Rsv1=clear,
			  Rsv2=clear,
			  Rsv3=clear,
			  Opcode=opc,
			  Masked=clear,
			  Payload_length=(String.size payload),
			  Masking_key= Nomask,
			  Payload=payload
			}
			
			fun wrapmsg (msg:MESSAGE,fin) = 
			  wrap(opSym2Hex(#Op msg), 
			    (#Message msg), fin);
			    
			fun fragment (msg:MESSAGE) = let
			  fun loop (opc, s, acc) = 
			    if (String.size s) > fragSize
			    then loop(
			      opContinuation,
			      String.extract(s,fragSize,NONE),
			      acc^^[wrap(opc, 
			        String.substring(s,0,fragSize), 
			        clear
			      )]
			    )
			    else 
			      acc^^[wrap(opc, s, set)];
			  in 
			    loop(
			      opSym2Hex(#Op msg), 
			      (#Message msg), 
			      [])
			  end;
			\end{lstlisting}
			
			The WSFRAME colours are then queued randomly one by one from the data queue or
			the control frame queue. This allows control frames to be injected between
			the parts of a fragmented data frame, as required by the WebSocket protocol
			specification. Control frames are prioritised, by the prescence of a
			two-way arc from the Control place to the Queue data transition, inscribed
			with \lstinline:[]:, which prevents it from being enabled if the list
			in the Control place is not empty. This priorisation is allowed but not
			required by the WebSocket protocol specification, but is included here to
			emphasise that control frames can be sent even between two fragmented data
			frames.
		
	\subsubsection{Unwrap and receive}
		
		\figrot[0.4]{UnwrapAndReceive.eps}{Unwrap And Receive
		submodule}{unwrap_and_receive}
		
		Received WebSocket frames that arrive in the Packet Received place at the
		bottom can take three paths. 
		
		The first is to the left, and happens if the
		connection is in the \lstinline:CONN_OPEN: state (checked on the arc) and the
		frame is not a close frame (checked in the guard of the Receive transition). The WebSocket
		frame is put in the Received WS Frame place, and if it is a Ping frame, a Pong
		frame is immediately queued for sending with identical message body. 
		
		The received frame is then checked on two points for fragmentation: If the Fin
		bit is set and the opcode is not continuation, it is not part of a fragmented
		message and converted directly to a MESSAGE. If either or both of those
		conditions are not true, tihs is part of a fragmented message and is processed
		in the Defrag submodule (explained below).
		
		The second path a frame can take is to the right, and happens if the
		connection is in the \lstinline:CONN_OPEN: state (checked on the arc) and the
		frame is a close frame (checked in the guard of the Receive transition). A
		close frame is created and set to be sent, and the
		connection state is changed to \lstinline:CONN_CLOSED:, since we have both
		received and sent a close frame. Note that the packetlist from Client Send is
		not appended to but instead discarded, because we can not expect the other
		end to process any more frames other than a close frame since it has already
		sent a close frame of its own.
		
		The third path is upwards and happens if the connection state is
		\lstinline:CONN_CLOSING:, which means a close frame has been sent and we are
		waiting for a reply. Any payload is ignored, and the connection state stays
		the same until a close frame is received, in which case the connection state
		is set to \lstinline:CONN_CLOSED:. 
		
		\paragraph{Defragmenting fragmented frames}
			
			\fig{Defrag.eps}{Defragment}{defragment}
			
			Frames that are part of a fragmented message should always arrive in a
			specific order, and correspond to each of the transitions on this module. 
			
			If the Fin bit is clear and the opcode is not continuation, this is the first
			frame in the series. A mew \lstinline:MESSAGE: is created with the opcode and
			payload from the WebSocket frame and put in the Buffer place.
			
			If the Fin bit is clear and the opcode is continuation, this frame belongs in
			the middle of the sequence. The payload is appended to the
			\lstinline:MESSAGE: in the Buffer place using the \lstinline:append():
			function.
			
			\begin{lstlisting}[label=lst:append,caption=append,gobble=3]
			fun append (msg:MESSAGE, s) = 
			  {Op = #Op msg,
			  Message = (#Message msg)^s}
			\end{lstlisting}
			
			If the Fin bit is set and the opcode is continuation, this is the last frame
			of the sequence. We append the payload to the message and put it in the final
			Completed message place. 
			
			Note that the WebSocket protocol does not allow fragmented messages to be
			interleaved, so it can be assumed that consecutive fragments belong to the
			same message. Fragment inerleaving can be defined by subprotocols, but this
			is not relevant to this model.
			
\subsection{Connection}

	\fig{Connection.eps}{The Connection module}{connection}
	
	\figref{connection} shows the connection; a very simple model. The packets that
	come from the Client Send place go to the Server Receive place, and from the
	Server Send place to the Client Receive place. The transportation of data
	between the client and the server as well as ensuring a stable connection is
	assumed to be taken care of by TCP, as the WebSocket protocol specifies, and
	is not necessary to model in detail to show how WebSocket works. 
	
	The packets are also not converted to pure bits or bytes. This decision was
	made to keep inspection easier during simulation. 

\subsection{The Server WebSocket Layer}
	
	\fig{ServerWebSocket.eps}{The Server WebSocket Layer}{server_wslib}
	
	The Server WebSocket layer is very similar to the Client version. The main
	differences are that instead of masking outgoing frames, we are checking
	incoming frames for a mask and unmasking them, and that we are checking for
	incoming connections and replying to them based on what the Server Application
	decides.
	
	The Server Application can send two types of coloursets: \lstinline:MESSAGE: and
	\lstinline:CONN_REPLY:. A special colourset has been made to accomodate this,
	\lstinline:MSG_OR_CONN_REPLY:. 
	
	The submodules that belong to the \lstinline:Wrap and Send: and the
	\lstinline:Unwrap and Receive: substitution transitions are the same as the ones for the Client Library. To
	be more precise, the Client Library and Server Library both have instances of
	the same submodule, so that editing the submodule model affects both parent
	modules while simulating them lets them have different states.
	
	\subsubsection{Get Connection Request}
		
		\fig{ConnectionRequest.eps}{Get Connection Request}{connection_req}
		
		This is a very abstract representation of how connection requests are
		received. The library simply sends a ConnRequest token to the app. In a real
		world app, much more info might have been sent, for example IP address and
		possibly authentication info, but for this model it is enough to show that
		some info is being sent, while the details are abstracted away. 

	\subsubsection{Send Connection Response}
		
		\fig{ConnectionResponse.eps}{Send Connection Response}{connection_res}
		
		When the Server Application has decided what to do with an incoming
		connection, it will send a \lstinline:CONN_REPLY: to the library. If the
		answer is \lstinline:accept:, we create a \lstinline:CONN_OPEN: token in the
		Active Connection place and send a HTTP response back to the client, properly
		formatted according to the rules of the WebSocket Protocol. This involves
		generating a Sec-WebSocket-Accept header, which is done with the
		generateAccept() function:
		
		
		\begin{lstlisting}[label=lst:generateAccept,caption=generateAccept,gobble=2]
		fun B64 str =
		  "B64("^str^")";
		
		fun SHA1 str =
		  "SHA1("^str^")";

		fun generateAccept str =
		  B64(SHA1(str^uuid));
		\end{lstlisting}
		
		The two functions B64() \cite{rfc4648} and SHA1() \cite{fips.180-2} are
		abscract versions of the Base64 encoding algorithm and the SHA1 hasing algorithm. We felt it was unneccessary
		to actually implement these for the purpose of this model, and instead decided
		to simply wrap the string argument to show that it had been encoded or hashed.
		
\subsection{Server Application}
	
	\fig{ServerApplication.eps}{The Server Application Module}{server_app}
	
	The Server Application has three tasks: Accept or reject incoming connections,
	and send and retrieve data. The colourset \lstinline:MSGS_OR_CONN_REPLY: that
	was defined in \lstref{overview_colset} is seen here. It has three
	queued messages, which illustrate the capability of PONG frames to be used as
	a heartbeat (without PING being involved). A real world application would have
	more logic here, but the interface to the library would be the same.
