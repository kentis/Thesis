\chapter{State Space Analysis of the WebSocket Protocol}\label{chap:statespace}One of the advantages of Coloured Petri Nets is the ability to conduct statespace analysis, which can be used to obtain information about thebehavioural properties, as well as to locate errorsand increase confidence in the correctness of a CPN model, and in our case thecommunication protocol being modeled.\section{State Spaces}A state space is a directed graph where each node represents a reachable marking(a state) and each arc represents an occurring binding element (a transitionfiring with values bound to the variables of the transition). CPN Tools willby default calculate the state space in breadth-first order. Once generated, the state space graph can be visualised directly in CPN Tools.For example, starting with the node for the initial state, one can pick a nodeand display all nodes that are reachable from it, and in this way explore the state spacemanually. This can be very tedious and unmanageable for complex state spaces,though, and instead it is usually better to use queries written in CPN ML toautomate the analysis based on state spaces.	\subsection{Strongly Connected Component graph}	In graph theory, a strongly connected component (SCC) of a graph is a maximal	subgraph where all nodes are reachable from each other. An SCC graph has a node	for each SCC of the graph, connected by arcs determined by the arcs in the	underlying graph between nodes that belong to different SCCs. An	SCC graph is acyclic, and an SCC is said to be trivial if it consists of only	one node from the underlying graph.		By calculating the SCC graph of the state space, the analysis of certain	properties becomes simpler and faster, such as determining reachability,	determining cyclic behaviour, and checking so-called home and liveness	properties.	\subsection{Application of State Spaces}		The biggest drawback of state space analysis is the size of the state space		may become very large. The number of nodes and arcs often grows exponentially		with the size of the model configuration.		This is also known as the state explosion problem.				\figDbl{ss/ClientApplicationNoMessagesCropped.eps}{Client}		{ss/ServerApplicationNoMessagesCropped.eps}{Server}{Configuration:		No messages}{ss_no_messages}			This can be remedied by picking smaller configurations that encapsulate		different parts of the system. This was necessary with the WebSocket Protocol		model, as the complete state space took too long to generate with our		original configuration (see \figref{client_app} and \figref{server_app}).		We started by removing all messages to be sent (shown in		\figref{ss_no_messages}).		This means the only thing that should happen during simulation is the opening		handshake. This configuration is used to explain the State Space Report in		the next section.		After this, we gradually added different types of messages to the client		and/or server applications. These configurations will be discussed at the end		of the chapter.				Another aspect that must be considered prior to state space analysis is		situations where an unlimited number of tokens can be generated on a place,		thus making the state space infinite. This can be remedied by modifying the model to		limit the number of simultaneous tokens in the offending place.				Additionally, a model that incorporates random values is not always suited		for computing a state space. The generated state space depends on the random		values chosen, so the state space generator needs to be able to		deterministically bind values to arc expression variables.						For small colour sets (generally defined as discrete types with less		than 100 possible values), binding of random values in arc expressions can		occur in two ways: 		\begin{enumerate}		\item By calling ran() on the colourset. The ran() function picks a value		ranging over the colour set, but since the choice is non-deterministic,		this construct is not suited for state space generation.		\item By using a free variable ranging over a colour set in the arc expression.		A free variable is a variable that does not get assigned a value in an expression. It will 		bind to a value picked at random from the colour set during simulation just		like the ran() function, but also lets the state space generator pick each of 		the possible bindings from the values available in the colourset, and thus		generate all possible successive states. 		\end{enumerate}				For arc expressions that use type 1, it is usually possible to change or		adapt it into type 2.				Colour sets that use values from a large or unbounded range, or from continuous		ranges like floating point numbers, are considered large colour sets, and using		random values from such colour sets can make it impossible (or impractical)		to generate a complete state space. It can be worked around by		instead using small colour sets as described above. The CPN Tools manual has		examples on how to do this.				If these issues are not taken into account, a complete state space can not be		obtained, since it is impossible for the state space genrator of CPN Tools to		make sure that all possible values have been considered, and occurrence		sequences might diverge if the same occurrence can happen in different orders but with different		random values.				For the WebSocket Protocol model, this was a problem for the masking		key in WebSocket frames, which is supposed to be a random 4-byte string,		giving $2^{32}$ or almost 4.3 billion possible values.		To generate state spaces for this model, the randomisation function used was		simply changed to always return four zeros. This is a reasonable abstraction		since the specific value of the masking key does not affect the operation of		the protocol. The result is shown in \lstref{fixed_masking_key}, with the old		code commented out.				\begin{lstlisting}[label=lst:fixed_masking_key,gobble=2,caption=Fixed masking		key] 		fun	randMask() = Mask([ 			0,0,0,0			(* BYTE.ran(), BYTE.ran(), BYTE.ran(), BYTE.ran() *)		]);		\end{lstlisting}		\subsection{Visualisation}	\fig[0.4]{ss/vis_NoMessages.eps}{State space for	configuration with no messages}{ss_vis_nomessage} CPN Tools can visualise a	state space once it has been calculated.	\figref{ss_vis_nomessage} shows the state space for the no messages	configuration. Rounded squares represent markings, and arcs represent	transition occurences. Clicking on the small triangle in the node will display	a node descriptor which shows the marking that is associated with the node.	Similarly, clicking on a state space arc will display an arc descriptor which	describes the binding element associated with the arc. \section{State Space Report}Once a partial or complete state space has been generated, CPN Tools lets theuser save a state space report as a textual document. The report is organisedinto parts that each describe different behavioural properties of the CPN model.To explain each section of the state space report, a simple report for theWebSocket protocol has been generated, in a configuration where no messages areset to be sent. Thus, the only thing that will happen is that a connection willbe established. Later in the chapter we will consider more elaborateconfigurations of the WebSocket protocol.		\subsection{Statistics}	The first section of the report is shown on \lstref{ssa_statistics} and	describes general statistics about the state space.	\begin{lstlisting}[language={},float=h,label=lst:ssa_statistics,	caption=State Space Report: Statistics]  State Space     Nodes:  17     Arcs:   16     Secs:   0     Status: Full  Scc Graph     Nodes:  17     Arcs:   16     Secs:   0	\end{lstlisting}	This state space has 17 possible markings, with 16 enabled transition	occurrences connecting them. There is one more node than there are arcs, which	means this graph is a tree (in fact it consists of just a single path as was	shown in \figref{ss_vis_nomessage})		The |Secs| field shows that it took less than one second to calculate this	state space, while the |Status| field specifies whether the report is generated	from a partial or full state space. In this case, the state space is fully	generated.		We also see that the SCC Graph has the same number of nodes and arcs, meaning	that there are no cycles in the state space (although this was already known	from the fact that it is a tree).		\subsection{Boundedness Properties}	The second section of the state space report , shown in \lstref{ssa_bib},	describes the minimum and maximum number of tokens for each place in the model, as well as the actual tokens these places can have.	The text has been reformatted and truncated (indicated by [\ldots]) for	readability.	\begin{lstlisting}[language={},float=h,label=lst:ssa_bib,	caption=State Space Report: Best Integer Bounds]    Best Integer Bounds                             Upper      Lower     ClientApplication          Active_Connection   1          0          Conn_Result         1          0          Connection_failed   0          0          Messages_received   1          1          Messages_to_be_sent 0          0     [...]	\end{lstlisting}		Many places have a lower and upper bound of 1. This shows a weakness	in the approach of using lists to facilitate ordered processing of tokens: We	cannot see the actual number of tokens (i.e. the number of elements in the	list) that are in each place, because technically there is just one token	there: the list itself.	However, it quickly lets us know if something is wrong as well, since any	values other than 0 or 1 here would indicate a problem. 		In fact, an error in the model was discovered this way, in the Unwrap and	Receive module, where the Pong reply was creating a new list instead of	appending to the old one in outgoing messages. This caused the \nodename{Client	Outgoing Messages} place to have 2 tokens at once. \figref{pong_fix} shows the	location of the error before and after fixing it.	\figDbl[0.35]{SSA_UnwrapAndReceive_Pong_before.eps}{Before}{SSA_UnwrapAndReceive_Pong_after.eps}{After}{Problem	with the Pong reply modeling}{pong_fix}		\begin{lstlisting}[language={},tabsize=4,float,label=lst:ssa_bmsb,	caption=State Space Report: Best Multi-set Bounds]  Best Upper Multi-set Bounds     ClientApplication          Active_Connection		1`()          Conn_Result			1`success          Connection_failed		empty          Messages_received		1`[]          Messages_to_be_sent	empty     [...]     ClientWebSocket          Connection_status		1`CONN_OPEN     [...]     ServerWebSocket          Connection_Status		1`CONN_OPEN     [...]  Best Lower Multi-set Bounds     ClientApplication          Active_Connection		empty          Conn_Result			empty          Connection_failed		empty          Messages_received		1`[]          Messages_to_be_sent	empty     [...]     ClientWebSocket          Connection_status		empty     [...]     ServerWebSocket          Connection_Status		empty     [...]	\end{lstlisting}		The Best Upper Multi-set Bounds, shown in \lstref{ssa_bmsb}, will show for each	place a set of every token that exists in that place at some point in the state space. We see that both	the client and the server has an open connection at some point, as the	\nodename{Connection\_status} place in the \nodename{ClientWebSocket} and	\nodename{ServerWebSocket} modules have both had a |CONN_OPEN| token.		The Best Lower Multi-set Bounds is the opposite, and shows the smallest set of	tokens that exists at any point in the state space. This is either the empty	list |[]| or simply |empty| for all places.		\subsection{Home Properties}	This section of the state space report, shown in \lstref{ssa_home}, shows all	home markings. A home marking is a marking that can always be reached from any	other reachable state in the state space.		\begin{lstlisting}[language={},float,label=lst:ssa_home,	caption=State Space Report: Home Properties]  Home Markings     [17]	\end{lstlisting}		We see that there is one such marking defined by node 17. From earlier we know	that the state space is a tree, and if this node is always reachable it must be a leaf	and all the other nodes must be in a chain. This agrees with the visualisation	shown earlier in \figref{ss_vis_nomessage} that there is only one possible	sequence of transition occurrences to establish a connection. CPN Tools	allows us to import the state from this node into the editor, and by manually	inspecting the various markings of the model to verify the desired state of	an open connection exists with no side effects, we can confidently say that the	model works correctly with this configuration.		\subsection{Liveness Properties}	This section of the state space report, shown in \lstref{ssa_liveness},	describes so-called liveness properties of the state space.	Some of the transitions have been omitted for readability.		\begin{lstlisting}[language={},float,label=lst:ssa_liveness,	caption=State Space Report: Liveness Properties]  Dead Markings     [17]  Dead Transition Instances     ClientApplication'Fail 1     ClientApplication'Receive_data 1     ClientApplication'Send_data 1     ClientWebSocket'Filter_messages 1     [...]  Live Transition Instances     None	\end{lstlisting}		A dead marking is a marking from where no other markings can be reached.	 In other words, there are no transitions	for which there are enabled bindings, and the system is effectivley stopped.	For our example, we have a single dead marking, and it is the same as our home	marking, confirming that this is a leaf node in the tree.		We also get a listing of dead transition instances, which are transitions that	never have any enabled bindings in a reachable marking and are thus never	fired. This can be useful to detect problems with a model, but in this example	it is expected for many of the transitions, since we are not sending any kind	of messages in the configuration considered.		Last, there are live transition instances. A transition is live if from any	reachable marking we can find an occurrence sequence containing the transition.	Our example has no such transition, which follows trivially from the fact that	there is a dead marking.	The state space report also contains fairness properties, but this does	not apply to our model sincethe state space does not contains cycles. We	will not go into detail about this, and instead refer to \cite{cpn_book},	chapter 7 for more information.	\subsection{Larger Configurations} 	Above we have considered the simplest possible configuration of the WebSocket	protocol model.Below we present the results from considering more complex	configurations. For each configuration we only present select elements from the	state space report	\subsubsection{Configuration 1: One short message}	The next step is to gradually increase the number of messages to be passed	between the endpoints. We start by configuring the client to send a single	message: |{Op=TEXT, Message="Short message"}|. The results are shown in	\lstref{ssa_one_msg}		\begin{lstlisting}[language={},float,label=lst:ssa_one_msg,caption=One message]  State Space     Nodes:  29     Arcs:   28     Secs:   0     Status: Full  Home Markings     [29]  Dead Markings     [29]  Live Transition Instances     None     No infinite occurrence sequences.	\end{lstlisting}		The number of markings has not increased by much, and the other properties are	largely the same, except there are fewer dead transition instances. 	The visualisation (\figref{ss_vis_1message}) shows there is still only one	chain of occurrences, and by manual inspection of state 29 we verified that	this state had the desired outcome without side effects (connection open and	message received).	\fig[0.4]{ss/vis_1Message.eps}{One message}{ss_vis_1message}		\subsubsection{Configuration 2: One ping, then one message}	When we add another message to be sent (a ping, which will also result in a	pong being sent back), we see in \lstref{ssa_ping_msg} that the number of nodes	has increased by an order of magnitude. This is due to the fact that for each	position the first message can have, the other message can be	anywhere from not sent yet to at the same place, yielding an exponential	increase in possible states.		\begin{lstlisting}[language={},float,label=lst:ssa_ping_msg,caption=One ping	then one message] State Space     Nodes:  475     Arcs:   1140     Secs:   1     Status: Full       Home Markings     [475]  Dead Markings     [475]	\end{lstlisting}		CPN Tools supports exporting state spaces to a format supported by Graphviz, an	open source application for visualising graphs. We have used Graphviz to	visualise this state space, shown in \figref{ss_vis_1ping1message}. This	clearly demonstrates the effect of the state space explosion problem. 		The home marking 475 was again manually verified as correct.		\fig[0.145]{ss/vis_1ping1message.eps}{State space for one ping, one	message configuration}{ss_vis_1ping1message}	\subsubsection{Configuration 3: One message, then one ping}	By reversing the order of the two messages, the state space gets slightly	larger, due to the fact that WebSocket could send the ping frame first, since	it is a control frame. Results are shown in \lstref{ssa_msg_ping}.		\begin{lstlisting}[language={},float,label=lst:ssa_msg_ping,caption=One	message then one ping]  State Space     Nodes:  513     Arcs:   1141     Secs:   1     Status: Full       Home Markings     None  Dead Markings     [512,513]	\end{lstlisting}		Note that we now no longer have any home marking, and instead have two dead	markings, representing the two possible orderings of the two messages. In this	situation it is possible to use the |HomeSpace| query to see if the markings	belong to a so-called home space, meaning for any reachable marking in the	state space, it is possible to reach at least one of the markings in the home	space. The full query used is |HomeSpace(ListDeadMarkings())|, and it returned	|true| when executed in this instance.		\subsubsection{Configuration 4: One long message}	We now set a message to be sent that is large enough to require fragmenting:		|{Op=TEXT,Message="Very long message. Very long message. |		|Very long message. Very long message. Very long message. "}|		\begin{lstlisting}[language={},float,label=lst:ssa_long_msg,caption=One long	message]  State Space     Nodes:  813     Arcs:   2331     Secs:   2     Status: Full       Home Markings     [813]  Dead Markings     [813]	\end{lstlisting}	We see in \lstref{ssa_long_msg} that this has more states than sending two	simple messages.	We can also use the Best Upper Multi-set Bounds section, shown in	\lstref{ssa_long_msg_frag} to find the largest collection of fragments. 		\begin{lstlisting}[language={},gobble=1,float,label=lst:ssa_long_msg_frag,caption=Upper	Multi-set Bounds - long message fragments]		1`[WsFrame({Fin=clear,Rsv1=clear,Rsv2=clear,Rsv3=clear,Opcode=1,Masked=set,Payload_length=20,Masking_key=Mask([0,0,0,0]),Payload="Very long message. V"}),	WsFrame({Fin=clear,Rsv1=clear,Rsv2=clear,Rsv3=clear,Opcode=0,Masked=set,Payload_length=20,Masking_key=Mask([0,0,0,0]),Payload="ery long message. Ve"}),	WsFrame({Fin=clear,Rsv1=clear,Rsv2=clear,Rsv3=clear,Opcode=0,Masked=set,Payload_length=20,Masking_key=Mask([0,0,0,0]),Payload="ry long message. Ver"}),	WsFrame({Fin=clear,Rsv1=clear,Rsv2=clear,Rsv3=clear,Opcode=0,Masked=set,Payload_length=20,Masking_key=Mask([0,0,0,0]),Payload="y long message. Very"}),	WsFrame({Fin=set,Rsv1=clear,Rsv2=clear,Rsv3=clear,Opcode=0,Masked=set,Payload_length=15,Masking_key=Mask([0,0,0,0]),Payload=" long message. "})]	\end{lstlisting}		We are also able to inspect every other possible combination, and can thus	confirm that messages are being split correctly.	\subsubsection{Configuration 5: Ping, text, close}	The client is now set to send three messages of different types: A ping	(which will solicit a pong), a short text string, and a	close message. With	three messages, state space calculation becomes noticeably time-consuming.	\lstref{ssa_ping_text_close} shows the results.		\begin{lstlisting}[language={},float,label=lst:ssa_ping_text_close,caption=Ping	Text Close]  State Space     Nodes:  6129     Arcs:   19625     Secs:   14     Status: Full       Dead Markings     6 [6129,6112,6029,5960,5632,...]	\end{lstlisting}		Here we have six dead markings. In three of the cases, the close is sent before	the text. For each of those three, the three cases consist of the pong frame	either successfully arriving at the client, not being received by the client due	to the connection being closed, or not being sent from the server for the same	reason. This was verified by manual inspection in CPN Tools. We also verified	that this set is a home space.	\subsubsection{Even larger configurations}	We tried adding one more message to the server application, but after running for	5 hours the state space calculation had still not been able to compute a	complete state space. Fortunately, it is still possible to create a report for	the partial graph, which we show in \lstref{ssa_large}. 		\begin{lstlisting}[language={},float,label=lst:ssa_large,caption=Large	configuration]  State Space     Nodes:  165748     Arcs:   707380     Secs:   18000     Status: Partial	\end{lstlisting}	The report also showed that it had not detected any cycles, which reinforces	the claim that the model works as it should.		\subsection{Summary}	State space analysis has proved to be very useful by uncovering problems	with the WebSocket CPN model, and effectively allowing us to conclude that the	model is now valid.  All but two of the transitions are enabled at some point;	the two exceptions are \nodename{Fail} in the \nodename{ClientApplication}	module and \nodename{Send Reject} in the \nodename{ConnectionResponse} module,	which correctly are never enabled.	This means we have full coverage of the model; no part of it is unused and	unaccounted for.