\chapter{State Space Analysis of the CPN Web Socket Protocol}\label{chap:statespace}One of the advantages of Coloured Petri Nets is the ability to conduct statespace analysis, which can be used to obtain information about thebehavioural properties of a CPN model, and which can be used to locate errorsand increase confidence in the correctness of the CPN model.\section{State Spaces}A state space is a directed graph where each node represents a reachable marking(a state) and each arc represents an occurring binding element (a transitionfiring with values bound to the variables of the transition). CPN Toolsby default generates the state space in breadth-first order. TODO: Figur av SS initiell modell, med forklaringOnce generated, the state space can be visualised directly in CPN Tools.Starting with the node for the initial state, one can pick a node and show allnodes that are reachable from it, and in this way explore the state spacemanually. This can be very tedious and unmanageable for complex state spaces,though, and instead it is usually better to use queries to automate the analysisbased on state spaces.	\subsection{Strongly Connected Component graph}	In graph theory, a strongly connected component (SCC) of a graph is a maximal	subgraph where all nodes are reachable from each other. An SCC graph has a node	for each SCC of the graph, connected by arcs determined by the arcs in the	underlying graph between nodes that belong to different SCCs. An	SCC graph is acyclic, and an SCC is said to be trivial if it consists of only	one node from the underlying graph.		By calculating the SCC graph of the state space, some of the further	analysis becomes simpler and faster, such as determining reachability,	cyclic behaviour, and checking so-called home and liveness properties. 	\subsection{Application of State Spaces}		The biggest drawback of state space analysis is the size a state spaces may		become very large. The number of nodes and arcs often grows exponentially		with the size of the model configuration.		This is also known as the state explosion problem.				This can be remedied by picking smaller configurations that encapsulate		different parts of the system. This was necessary with the WebSocket Protocol		model, as the complete state space took too long to generate with our		original configuration. \com{illustrasjon}		We started by removing all messages to be sent. This means the only thing that		should happen during simulation is the opening handshake. This configuration		is used to explain the State Space Report in the next section.		After this, we gradually added different types of messages to the client		and/or server applications. These configurations will be discussed at the end		of the chapter.				Another aspect that must be considered prior to state space analysis is		situations where an unlimited number of tokens can be generated, thus making		the state space infinite. This can be remedied by modifying the model to		limit the number of simultaneous tokens in the offending place.				Additionally, a model that incorporates random values is not always suited		for computing a state space. The generated state space depends on the random		values chosen, so the state space generator needs to be able to		deterministically bind values to arc expression variables.						For small color sets (generally defined as discrete sets usually with less		than 100 possible values), binding of random values in arc expressions can		occur in two ways: 		\begin{enumerate}		\item By calling ran() on the colorset. The ran() function  over the		color set, but since is non-deterministic, it isn't suited for state space		generation.		\item By using a free variable ranging over a color set in the arc expression.		A free variable is a variable that does not get assigned a value in an expression. It will 		bind to a value picked at random from the color set during simulation just		like the ran() function, but also lets the state space generator pick each of 		the possible bindings from the values available in the colorset, and thus		generate all possible successive states. 		\end{enumerate}				For arc expressions that use type 1, it is usually possible to change or		adapt it into type 2.				Color sets that use values from a large or unbounded range, or from continuous		ranges like floating point numbers, are considered large color sets, and using		random values from such color sets can make it impossible (or impractical)		to generate a complete state space. It can be worked around by		instead using small color sets as described above. The CPN Tools manual has		examples on how to do this.				If these issues are not taken into account, a complete state space can not be		achieved, since it's impossible for the state space genrator to make sure all		possible values have been considered, and occurrence sequences might diverge		if the same occurrence can happen in different orders but with different		random values.				For the WebSocket Protocol model, this was a problem for the masking		key in WebSocket frames, which is supposed to be a random 4-byte string,		giving $2^{32}$ or almost 4.3 billion possible values.		To generate state spaces for this model, the randomisation function used was		simply changed to always return four zeros. This is a reasonable abstraction		since the specific value of the masking key does not affect the operation of		the protocol. The result is shown in \lstref{fixed_masking_key}, with the old		code commented out.			\begin{lstlisting}[label=lst:fixed_masking_key,caption=Fixed masking key] 	fun	randMask() = Mask([ 		Byte(0),Byte(0),Byte(0),Byte(0)		(* BYTE.ran(), BYTE.ran(), BYTE.ran(), BYTE.ran() *)	]);	\end{lstlisting}\section{State Space Report}Once a partial or complete state space has been generated, CPN Tools lets theuser save a state space report as a textual document. The report is organisedinto parts that each describe different behavioural properties of the statespace.To explain each section of the state space report, a simple report for theWebSocket protocol has been generated, in a configuration where no messages areset to be sent. Thus, the only thing that will happen is that a connection willbe established. Later in the chapter we will consider more elaborateconfigurations of the WebSocket protocol.		\subsection{Statistics}	The first section of the report describes general statistics about the state	space.	\begin{lstlisting}  State Space     Nodes:  17     Arcs:   16     Secs:   0     Status: Full  Scc Graph     Nodes:  17     Arcs:   16     Secs:   0	\end{lstlisting}	This state space has 17 possible markings, with 16 enabled transition	occurrences connecting them. There is one more node than there are arcs, which	means this graph is a tree.		The |Secs| field shows that it took less than one second to calculate this	state space, while the |Status| field tells whether the report is generated	from a partial or full state space. In this case the state space is fully	generated.		We also see that the SCC Graph has the same number of nodes and arcs, meaning	that there are no cycles in the state space (although this was already known	from the fact that it is a tree).		\subsection{Boundedness Properties}	The second section describes the minimum and maximum number of tokens for	each place in the model, as well as the actual tokens these places can have.	The text has been reformatted and truncated (indicated by [\ldots]) for	readability.	\begin{lstlisting}[language={}]  Best Integer Bounds                             Upper      Lower     ClientApplication          Active_Connection                             1          0          Conn_Result                             1          0          Connection_failed                             0          0          Messages_received                             1          1          Messages_to_be_sent                             0          0     [...]	\end{lstlisting}		Many places show a lower and upper bound of 1. This shows a weakness	in the approach of using lists to facilitate ordered processing of tokens: We	cannot see the actual number of tokens that are in the place, because	technically there is just a list there. However, it quickly lets us know if	something is wrong as well, since any values other than 0 or 1 here indicate a	problem. 		In fact, an error in the model was discovered this way, in the Unwrap and	Receive module, where the pong reply was creating a new list instead of	appending to the old one in outgoing messages. This caused the Client Outgoing	Messages place to have 2 tokens at once. \figref{pong_fix} shows the location	of the error before and after fixing it.	\figDbl[0.35]{SSA_UnwrapAndReceive_Pong_before.eps}{Before}{SSA_UnwrapAndReceive_Pong_after.eps}{After}{Fixing	Pong reply}{pong_fix}		\begin{lstlisting}[language={}]  Best Upper Multi-set Bounds     ClientApplication          Active_Connection                         1`()          Conn_Result                         1`success          Connection_failed                         empty          Messages_received                         1`[]          Messages_to_be_sent                         empty     [...]     ClientWebSocket          Connection_status                         1`CONN_OPEN     [...]     ServerWebSocket          Connection_Status                         1`CONN_OPEN     [...]  Best Lower Multi-set Bounds     ClientApplication          Active_Connection                         empty          Conn_Result                         empty          Connection_failed                         empty          Messages_received                         1`[]          Messages_to_be_sent                         empty     [...]     ClientWebSocket          Connection_status                         empty     [...]     ServerWebSocket          Connection_Status                         empty     [...]	\end{lstlisting}		Apart from that, we see that both the client and the server has an open	connection at some point, as the |Connection_status| place in the	|ClientWebSocket| and |ServerWebSocket| modules have both had a |CONN_OPEN|	token.		\subsection{Home Properties}	This section shows all home markings. A home marking is a marking that can	always be reached no matter where we are in the state space. 	\begin{lstlisting}[language={}]  Home Markings     [17]	\end{lstlisting}	We see that there is one such marking defined by node 17. From earlier we know	that the state space is a tree, and if this node is always reachable it must be a leaf	and all the other nodes must be in a chain. This tells us that there is only	one possible sequence of transitions to establish a connection. We can then	confidently say that the model works correctly with this configuration.		\subsection{Liveness Properties}	This section describes liveliness of the state space. Some of the transitions	have been omitted for readability.		\begin{lstlisting}[language={}]  Dead Markings     [17]  Dead Transition Instances     ClientApplication'Fail 1     ClientApplication'Receive_data 1     ClientApplication'Send_data 1     ClientWebSocket'Filter_messages 1     .....  Live Transition Instances     None	\end{lstlisting}		A dead marking is a marking from where no other markings can be reached.	\com{from where? for which? formuler} In other words, there are no transitions	for which there are enabled bindings, and the system is effectivley stopped.	For our example, we have a single dead marking, and it is the same as our home	marking, confirming that this is a leaf node in the tree.		We also get a listing of dead transition instances, which are transitions that	never have any enabled bindings in a reachable marking and are thus never	fired. This can be useful to detect problems with a model, but in this example	it is expected for many of the transitions, since we are not sending any kind	of messages in the configuration considered.		Last, there are live transition instances. A transition is live if we from any	reachable marking can find an occurrence sequence containing the transition.	Our example has no such transition, which follows trivially from the fact that	there is a dead marking.	The state space report also contains fairness properties, but this does	not apply to our model since it contains no cycles. We will not go into detail	about this, and instead refer to \cite{cpn_book} chapter 7 for more	information.	\section{TODO:} Skrive om resten av analysene.