\chapter{Technology and Foundations}
\label{chap:technology}

One of the first decisions that had to be made for this thesis was whether to
base the work on some existing platform or to create a new one from
scratch. In this chapter we will describe the reasoning behind the
design choices we made, and give an overview of the technologies that have been
used.

TODO: Krav

\section{Representing CPN Models}
	A (??? utydelig) design decision is how to represent the CPN models. A simple
	but easy way of manipulating a CPN model is by representing it as a tree, with pages as
	nodes, and places, transitions and arcs as child nodes with properties
	describing how they connect in the actual CPN model.
	Simple tree editors are a feature of most GUI software platforms.
	Even so, we realised early that writing everything from scratch would take
	much longer than adapting an existing platform.

	There are of course many complete implementations of Petri Net tools in
	different languages and toolkits, but few of them are open source, or written
	with extensibility in mind. If we were to base our work on an existing
	platform, it would have to be open and extendable. 
	
	To narrow our search, we limited our options to solutions in
	languages we had experience with: Java, c++/Qt and Ruby. Java is a popular
	language, and we already have Access/CPN, a part of the CPN Tools project,
	which can parse .cpn files and represent the model as Java objects. 
	
	The ePNK framework, an extendable framework for working with Petri Nets in a
	graphical manner, and that makes it possible to specify your own Petri Net
	type. It is built on the Eclipse Modeling Framework (EMF) (which Access/CPN is
	also built on).
	
	We also needed a way to represent pragmatics. It was suggested to try an
	ontology-based approach, and we selected Semantic Application Design Language
	(SADL), another Eclipse plugin that lets us easily define and work with ontologies.
	
	\fig{AppOverviewDiagram.pdf}{Application Overview Diagram}{app_overview}
	
	\figref{app_overview} shows the different elements that make up the application.
	The elements with bold frames are the ones newly created for this thesis, while
	the rest below are the existing solutions used and built upon. These will be
	described in the following sections, from the bottom up.

\section{Eclipse IDE}
Eclipse IDE \cite{eclipse} is an open source, cross-platform, polyglot
development environment.
Its plugin framework makes it highly extendable and customisable, and
especially makes it easy for developers to quickly create anything from small
custom macros, to advanced editors, to whole applications. The Eclipse IDE is
open source, and part of the Eclipse Project, a community for incubating and
developing open source projects.

\fig{EclipsePlatformDiagram.pdf}{The Eclipse RCP}{eclipse_rcp}

The Eclipse IDE is built on the Eclipse Rich Client Platform (RCP) shown in
\figref{eclipse_rcp}. At the bottom of this we have the Platform Runtime, based
on the OSGi framework, which provides the plugin architecture.

\com{TODO}
The Workspace 

THe Workbench 

The Team plugin is a foundation for collaboration and versioning systems. It
unifies many operations that are common between version control systems\ldots

The Help plugin 

Together these plugins form a basic generic IDE. Other plugins build on this to
specialise the environment for a programming language and/or type of
application.

The principal Eclipse distribution is the Eclipse Java IDE, which is one of the
most popular tools for developing Java applications, from small
desktop applications, to mobile apps for Android, to web applications, to
enterprise-scale solutions. 

Plugins are the building blocks of Eclipse, and there exists a wide range of
plugins that add tools, functionality and services. For example, this thesis
was written in \LaTeX{} using the Texlipse plugin, and managed with the Git
version control system through the EGit plugin. 

Publishing a custom plugin is simple. By packaging it and serving it on a
regular web server, anyone can add the web server URL to the update manager in
Eclipse, and it will let you download and install it directly, as well as
enabling update notifications.

It is possible to package Eclipse with sets of
plugins to form custom editions of Eclipse that are tailored for specific
environments and programming languages. Aptana Studio is one example, aimed at
Ruby on Rails and PHP development.


\section{Eclipse Modeling Framework (EMF)}
EMF is a framework for Model Driven Development (MDD) in Java. It is an Eclipse
plugin that is part of the Eclipse Platform, and is open source. The principle
of MDD is to define model structure by creating a metamodel to specify which
entities can be created and how they relate to each other. By providing modeling
and code generation tools, EMF allows developers to create model specifications
(metamodels) that can be converted to Java classes, along with a set of adapter
classes that enable viewing and command-based editing of the model, and a basic
editor. These capabilities make EMF ideal for obtaining a simple editor that can
be used to manipulate CPN models. 

\com{EKSEMPEL}

	\subsection{Graphical Modeling Framework (GMF)}
	GMF builds on EMF to provide graphical viewing and editing of models. It uses
	metamodels created with EMF to generate implementations of views and editors
	that can create and edit the respective models. This can be used to create an
	editor that looks and works similarly to CPN Tools, and also lets you annotate
	it with pragmatics.

\section{ePNK: Petri Net framework}
ePNK is an Eclipse plugin both for working with standard Petri Net models, and a
platform for creating new tools for specialised Petri Net types, which is
exactly what we need for our annotated Petri Net type. It uses EMF and GMF to
work with the Petri Net models and provide generic editors for custom Petri Net variants.

There are several reasons why ePNK is a good choice:
\begin{itemize}
	\item It saves models using the ISO/IEC 15909 \com{referanse?} standard file
	format Petri Net Markup Language (PNML),
	\item It is currently actively developed,
	\item It is designed to be generic and easily extendable by creating new model
	types, and
	\item It includes both a tree editor and a graphical editor, provided through
	GMF.
\end{itemize}

ePNK includes definitions for the core PNML model type, as well as two
subtypes of Petri Nets. The first is P/T-Nets (Place/Transition Nets), which
expand on the core model with a few key items: initial markings for placesas
integers, inscriptions on arcs, and constraining arcs to only go between a place
and a transition (this is not enforced in PNML, as there are Petri Net variants that
allow this). 

The second type included with ePNK is High level Petri Nets (HLPNG). This type
adds Structured Labels which are used to represent model declarations, initial
markings, arc expressions and transition guards.
These are parsed and validated using a syntax that is inspired from (but not the
same as) CPN ML from CPN Tools. It is possible to write invalid data in these
labels and still save the document, as they will only be marked as invalid by
the editor to inform the user.

Neither of these two types conform exactly to the Coloured Petri Nets created by
CPN Tools. HLPNG comes close, but is missing a few things like ports and sockets
(RefPlaces can emulate this), and substitutin transitions. Also, the
structured labels are not compatible with CPN ML syntax from CPN Tools, and for
our prototype, these structured labels are not necessary with regard to
annotations. They might be useful in a future version, where for example
pragmatics are available depending on things like the colorset of a place or the
variables on an arc, but initially this is considered to be out of the scope of
this thesis.

Our decision was therefore to develop our own Petri net type that matches the
type supported by CPN Tools.

\section{Access/CPN: Java interface for CPN Tools}
CPN Tools has a sister project called Access/CPN. This is an
EMF-based tool to parse .cpn files and represent them as an
EMF-model. The .cpn files saved by CPN Tools are XML-based, which makes them
easy to parse, but having an existing solution for this is preferrable.

The model definition used by Access/CPN is very similar to that of ePNK.
\com{Diskutere mer i implementation?}



\section{Semantic Application Design Language (SADL): Ontologies}
Ontologies are a way to present information and meta-information so that it can
be understood by computers. Essentially, this is done by defining classes that
have properties, relations and constraints, and then present
information with these classes.

There is a lot of ongoing research on this subject, especially to create a
semantic web, that is extending web pages to provide meta-information about the
content they contain and enabling software to understand it and reason about it.
The Web Ontology Language (OWL) \com{Ref, sjekk om det er ISO} is the standard
for representing ontologies.

SADL is an Eclipse plugin that defines an english-like syntax for defining
ontologies, and comes with a text editor that features syntax highlighting,
parsing and validation. This is useful as we can possibly reuse the editor in
our plugin for defining model-specific pragmatics. SADL ontologies can be
compiled to OWL format.

It also has tools to parse and reason with these ontologies, which we will use
to filter and validate which pragmatics are available for different model
entities. 

TODO: Lite eksempel p√• ontology.

\section{Summary}
After picking these technologies, since all the componets have Eclipse in
common, it was an easy decision to develop our project as an Eclipse plugin.
This also let us centralise all our development in Eclipse.
